// MonoGame Effect Parser
//
// For use with our fork of the "Tiny Parser Generator"
// https://github.com/SickheadGames/TinyPG
//

<% @TinyPG Namespace="TwoMGFX" Language="C#"%>

[Skip] BlockComment -> @"/\*([^*]|\*[^/])*\*/";
[Skip] Comment -> @"//[^\n\r]*";
[Skip] Whitespace -> @"[ \t\n\r]+";
[Skip] LinePragma -> @"#line[^\n]*\n";

// TOKENS
Identifier -> @"[A-Za-z_][A-Za-z0-9_]*";
[IgnoreCase] Pass -> @"pass";
[IgnoreCase] Technique -> @"technique";
[IgnoreCase] VertexShader -> @"VertexShader";
[IgnoreCase] PixelShader -> @"PixelShader";
OpenBracket -> @"{";
CloseBracket -> @"}";
Equals -> @"=";
Semicolon -> @";";
OpenParenthesis -> @"\(";
CloseParenthesis -> @"\)";
[IgnoreCase] Compile -> @"compile";
[IgnoreCase] ShaderModel -> @"(vs_|ps_)(2_0|3_0|4_0|5_0)((_level_)(9_1|9_2|9_3))?";

[IgnoreCase] SamplerType -> @"(sampler|sampler1D|sampler2D|sampler3D|samplerCUBE|sampler_state|SamplerState)?";
[IgnoreCase] Address -> @"(AddressU|AddressV|AddressW)";
[IgnoreCase] AddressMode -> @"(Wrap|Mirror|Clamp|Border|MirrorOnce)";
[IgnoreCase] Texture -> @"Texture";
OpenElement -> @"<";
CloseElement -> @">";

Code -> @".";
EndOfFile -> @"^$";

//LinePragma -> @"#line";
//Integer -> @"[0-9]+";
//String -> @"@?\""(\""\""|[^\""])*\""";

// Productions
Start -> (Code | Technique_Declaration)+ EndOfFile
{
   var shader = new ShaderInfo();

   foreach (var node in Nodes)
   {
      var technique = node.Eval(tree, shader) as TechniqueInfo;
      if ( technique != null )
         shader.Techniques.Add(technique);
   }

   return shader; 
};

/*
LinePragma_Declaration -> LinePragma Integer String
{
   var filename = $String as string;
   var lineNumber = int.Parse($Integer as string);
   return null;
};
*/

Sampler_Declaration -> SamplerType Identifier Equals SamplerType OpenBracket (Sampler_Address_State_Declaration|Sampler_Texture_State_Declaration)* CloseBracket Semicolon;

Sampler_Address_State_Declaration -> Address Equals AddressMode Semicolon
{
   return null;
};

Sampler_Texture_State_Declaration -> Texture Equals OpenElement Identifier CloseElement Semicolon
{
   return null;
};

Technique_Declaration -> Technique Identifier? OpenBracket Pass_Declaration* CloseBracket 
{
   var technique = new TechniqueInfo();
   technique.name = $Identifier as string ?? string.Empty;
   technique.startPos = Token.StartPos;
   technique.length = Token.Length;

   foreach (var node in Nodes)
   {
      var pass = node.Eval(tree, technique) as PassInfo;
      if (pass != null)
         technique.Passes.Add(pass);
   }
   
   return technique.Passes.Count > 0 ? technique : null;
};

Pass_Declaration ->	Pass Identifier? OpenBracket (VertexShader_Pass_Expression | PixelShader_Pass_Expression)* CloseBracket 
{ 
   var pass = new PassInfo();
   pass.name = $Identifier as string ?? string.Empty;

   foreach (var node in Nodes)
      node.Eval(tree, pass);

   // If we don't have a pixel or vertex shader then skip this technique.
   if (string.IsNullOrEmpty(pass.psFunction) && string.IsNullOrEmpty(pass.vsFunction))
      return null;

   return pass;
};

VertexShader_Pass_Expression -> VertexShader Equals Compile ShaderModel Identifier OpenParenthesis CloseParenthesis Semicolon
{
   var pass = paramlist[0] as PassInfo;
   pass.vsModel = $ShaderModel as string;
   pass.vsFunction = $Identifier as string;
   return null;
};

PixelShader_Pass_Expression -> PixelShader Equals Compile ShaderModel Identifier OpenParenthesis CloseParenthesis Semicolon
{
   var pass = paramlist[0] as PassInfo;
   pass.psModel = $ShaderModel as string;
   pass.psFunction = $Identifier as string;
   return null;
};


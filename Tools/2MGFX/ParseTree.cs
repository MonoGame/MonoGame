// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace TwoMGFX
{
    #region ParseTree
    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        private string file;
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public string File { get { return file; } }
        public int Code { get { return code; } }
        public int Line { get { return line; } }
        public int Column { get { return col; } }
        public int Position { get { return pos; } }
        public int Length { get { return length; } }
        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code, node.Token)
        {
        }

        public ParseError(string message, int code, Token token) : this(message, code, token.File, token.Line, token.Column, token.StartPos, token.Length)
        {
        }

        public ParseError(string message, int code) : this(message, code, string.Empty, 0, 0, 0, 0)
        {
        }

        public ParseError(string message, int code, string file, int line, int col, int pos, int length)
        {
            this.file = file;
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }
    }

    // rootlevel of the node tree
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// this is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">additional optional input parameters</param>
        /// <returns>the output of the evaluation function</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }
    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        public List<ParseNode> Nodes { get {return nodes;} }
        
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text { // text to display in parse tree 
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;

            switch (Token.Type)
            {
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;
                case TokenType.Technique_Declaration:
                    Value = EvalTechnique_Declaration(tree, paramlist);
                    break;
                case TokenType.Render_State_Expression:
                    Value = EvalRender_State_Expression(tree, paramlist);
                    break;
                case TokenType.Pass_Declaration:
                    Value = EvalPass_Declaration(tree, paramlist);
                    break;
                case TokenType.VertexShader_Pass_Expression:
                    Value = EvalVertexShader_Pass_Expression(tree, paramlist);
                    break;
                case TokenType.PixelShader_Pass_Expression:
                    Value = EvalPixelShader_Pass_Expression(tree, paramlist);
                    break;
                case TokenType.Sampler_State_Expression:
                    Value = EvalSampler_State_Expression(tree, paramlist);
                    break;
                case TokenType.Sampler_Register_Expression:
                    Value = EvalSampler_Register_Expression(tree, paramlist);
                    break;
                case TokenType.Sampler_Declaration:
                    Value = EvalSampler_Declaration(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            var shader = new ShaderInfo();
        
           foreach (var node in Nodes)
              node.Eval(tree, shader);
        
           return shader;
        }

        protected virtual object EvalTechnique_Declaration(ParseTree tree, params object[] paramlist)
        {
            var technique = new TechniqueInfo();
           technique.name = this.GetValue(tree, TokenType.Identifier, 0) as string ?? string.Empty;
           technique.startPos = Token.StartPos;
           technique.length = Token.Length;
        
           foreach (var node in Nodes)
              node.Eval(tree, technique);
           
           // Make sure we have at least one pass.
           if (technique.Passes.Count > 0)
           {
              var shaderInfo = paramlist[0] as ShaderInfo;
              shaderInfo.Techniques.Add(technique);
           }
        
           return null;
        }

        protected virtual object EvalRender_State_Expression(ParseTree tree, params object[] paramlist)
        {
            var pass = paramlist[0] as PassInfo;
        	var name = this.GetValue(tree, TokenType.Identifier, 0) as string;
        	var value = (this.GetValue(tree, TokenType.Identifier, 1) ?? this.GetValue(tree, TokenType.Number, 0)) as string;
        	
        	Microsoft.Xna.Framework.Graphics.Blend blend;
        	
        	switch (name.ToLower())
        	{
        		case "alphablendenable":
        			if (!ParseTreeTools.ParseBool(value))
        			{
        				if (pass.blendState == null)
        					pass.blendState = new Microsoft.Xna.Framework.Graphics.BlendState();
        				pass.blendState.AlphaSourceBlend = Microsoft.Xna.Framework.Graphics.Blend.One;
        				pass.blendState.ColorSourceBlend = Microsoft.Xna.Framework.Graphics.Blend.One;
        				pass.blendState.ColorDestinationBlend = Microsoft.Xna.Framework.Graphics.Blend.Zero;
        				pass.blendState.AlphaDestinationBlend = Microsoft.Xna.Framework.Graphics.Blend.Zero;
        			}
        			break;
        		case "srcblend":
        			blend = ParseTreeTools.ParseBlend(value);
        			if (pass.blendState == null)
        				pass.blendState = new Microsoft.Xna.Framework.Graphics.BlendState();
        			pass.blendState.AlphaSourceBlend = blend;
        			pass.blendState.ColorSourceBlend = blend;
        			break;
        		case "destblend":
        			blend = ParseTreeTools.ParseBlend(value);
        			if (pass.blendState == null)
        				pass.blendState = new Microsoft.Xna.Framework.Graphics.BlendState();
        			pass.blendState.AlphaDestinationBlend = blend;
        			pass.blendState.ColorDestinationBlend = blend;
        			break;
        		case "blendop":
        			if (pass.blendState == null)
        				pass.blendState = new Microsoft.Xna.Framework.Graphics.BlendState();
        			pass.blendState.AlphaBlendFunction = ParseTreeTools.ParseBlendFunction(value);
        			break;
        		case "zenable":
        			if (pass.depthStencilState == null)
        				pass.depthStencilState = new Microsoft.Xna.Framework.Graphics.DepthStencilState();
        			pass.depthStencilState.DepthBufferEnable = ParseTreeTools.ParseBool(value);
        			break;
        		case "zwriteenable":
        			if (pass.depthStencilState == null)
        				pass.depthStencilState = new Microsoft.Xna.Framework.Graphics.DepthStencilState();
        			pass.depthStencilState.DepthBufferWriteEnable = ParseTreeTools.ParseBool(value);
        			break;
        		case "depthbias":
        			if (pass.rasterizerState == null)
        				pass.rasterizerState= new Microsoft.Xna.Framework.Graphics.RasterizerState();
        			pass.rasterizerState.DepthBias = float.Parse(value);
        			break;
        		case "cullmode":
        			if (pass.rasterizerState == null)
        				pass.rasterizerState= new Microsoft.Xna.Framework.Graphics.RasterizerState();
        			pass.rasterizerState.CullMode = ParseTreeTools.ParseCullMode(value);
        			break;
        		case "fillmode":
        			if (pass.rasterizerState == null)
        				pass.rasterizerState= new Microsoft.Xna.Framework.Graphics.RasterizerState();
        			pass.rasterizerState.FillMode = ParseTreeTools.ParseFillMode(value);
        			break;
        		case "multisampleantialias":
        			if (pass.rasterizerState == null)
        				pass.rasterizerState= new Microsoft.Xna.Framework.Graphics.RasterizerState();
        			pass.rasterizerState.MultiSampleAntiAlias = ParseTreeTools.ParseBool(value);
        			break;
        		case "slopescaledepthbias":
        			if (pass.rasterizerState == null)
        				pass.rasterizerState= new Microsoft.Xna.Framework.Graphics.RasterizerState();
        			pass.rasterizerState.SlopeScaleDepthBias = float.Parse(value);
        			break;
        		default:
        			break;
        	}
        	
        	return null;
        }

        protected virtual object EvalPass_Declaration(ParseTree tree, params object[] paramlist)
        {
            var pass = new PassInfo();
           pass.name = this.GetValue(tree, TokenType.Identifier, 0) as string ?? string.Empty;
        
           foreach (var node in Nodes)
              node.Eval(tree, pass);
        
           // We need to have a pixel or vertex shader to keep this pass.
           if (!string.IsNullOrEmpty(pass.psFunction) || !string.IsNullOrEmpty(pass.vsFunction))
           {
              var technique = paramlist[0] as TechniqueInfo;
              technique.Passes.Add(pass);
           }
        
           return null;
        }

        protected virtual object EvalVertexShader_Pass_Expression(ParseTree tree, params object[] paramlist)
        {
            var pass = paramlist[0] as PassInfo;
           pass.vsModel = this.GetValue(tree, TokenType.ShaderModel, 0) as string;
           pass.vsFunction = this.GetValue(tree, TokenType.Identifier, 0) as string;
           return null;
        }

        protected virtual object EvalPixelShader_Pass_Expression(ParseTree tree, params object[] paramlist)
        {
            var pass = paramlist[0] as PassInfo;
           pass.psModel = this.GetValue(tree, TokenType.ShaderModel, 0) as string;
           pass.psFunction = this.GetValue(tree, TokenType.Identifier, 0) as string;
           return null;
        }

        protected virtual object EvalSampler_State_Expression(ParseTree tree, params object[] paramlist)
        {
            var sampler = paramlist[0] as SamplerStateInfo;
        	var name = this.GetValue(tree, TokenType.Identifier, 0) as string;
        	var value = (this.GetValue(tree, TokenType.Identifier, 1) ?? (this.GetValue(tree, TokenType.Identifier, 2) ?? this.GetValue(tree, TokenType.Number, 0))) as string;
        	switch (name.ToLower())
        	{
        		case "texture":
        			sampler.textureName = value;
        			break;
        		case "minfilter":
        			sampler.MinFilter = ParseTreeTools.ParseTextureFilterType(value);
        			break;
        		case "magfilter":
        			sampler.MagFilter = ParseTreeTools.ParseTextureFilterType(value);
        			break;
        		case "mipfilter":
        			sampler.MipFilter = ParseTreeTools.ParseTextureFilterType(value);
        			break;
        		case "filter":
        			sampler.MinFilter = sampler.MagFilter = sampler.MipFilter = ParseTreeTools.ParseTextureFilterType(value);
        			break;
        		case "addressu":
        			sampler.state.AddressU = ParseTreeTools.ParseAddressMode(value);
        			break;
        		case "addressv":
        			sampler.state.AddressV = ParseTreeTools.ParseAddressMode(value);
        			break;
        		case "addressw":
        			sampler.state.AddressW = ParseTreeTools.ParseAddressMode(value);
        			break;
        		case "maxanisotropy":
        			sampler.state.MaxAnisotropy = int.Parse(value);
        			break;
        		case "maxlod":
        			sampler.state.MaxMipLevel = int.Parse(value);
        			break;
        		case "miplodbias":
        			sampler.state.MipMapLevelOfDetailBias = float.Parse(value);
        			break;
        		default:
        			break;
        	}
        
        	return null;
        }

        protected virtual object EvalSampler_Register_Expression(ParseTree tree, params object[] paramlist)
        {
            return null;
        }

        protected virtual object EvalSampler_Declaration(ParseTree tree, params object[] paramlist)
        {
            if (this.GetValue(tree, TokenType.SamplerState, 0) == null)
        		return null;
        	
        	var sampler = new SamplerStateInfo();
        	sampler.name = this.GetValue(tree, TokenType.Identifier, 0) as string;
        	sampler.state = new Microsoft.Xna.Framework.Graphics.SamplerState();	
        	
        	foreach (ParseNode node in Nodes)
        		node.Eval(tree, sampler);
        	
        	// Figure out what kind of filter to set based on each individual min, mag, and mip filter
        	if (sampler.MinFilter == TextureFilterType.Anisotropic)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.Anisotropic;
        	else if (sampler.MinFilter == TextureFilterType.Linear && sampler.MagFilter == TextureFilterType.Linear && sampler.MipFilter == TextureFilterType.Linear)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.Linear;
        	else if (sampler.MinFilter == TextureFilterType.Linear && sampler.MagFilter == TextureFilterType.Linear && sampler.MipFilter == TextureFilterType.Point)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.LinearMipPoint;
        	else if (sampler.MinFilter == TextureFilterType.Linear && sampler.MagFilter == TextureFilterType.Point && sampler.MipFilter == TextureFilterType.Linear)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.MinLinearMagPointMipLinear;
        	else if (sampler.MinFilter == TextureFilterType.Linear && sampler.MagFilter == TextureFilterType.Point && sampler.MipFilter == TextureFilterType.Point)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.MinLinearMagPointMipPoint;
        	else if (sampler.MinFilter == TextureFilterType.Point && sampler.MagFilter == TextureFilterType.Linear && sampler.MipFilter == TextureFilterType.Linear)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.MinPointMagLinearMipLinear;
        	else if (sampler.MinFilter == TextureFilterType.Point && sampler.MagFilter == TextureFilterType.Linear && sampler.MipFilter == TextureFilterType.Point)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.MinPointMagLinearMipPoint;
        	else if (sampler.MinFilter == TextureFilterType.Point && sampler.MagFilter == TextureFilterType.Point && sampler.MipFilter == TextureFilterType.Point)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.Point;
        	else if (sampler.MinFilter == TextureFilterType.Point && sampler.MagFilter == TextureFilterType.Point && sampler.MipFilter == TextureFilterType.Linear)
        		sampler.state.Filter = Microsoft.Xna.Framework.Graphics.TextureFilter.PointMipLinear;
        
        	var shaderInfo = paramlist[0] as ShaderInfo;
        	shaderInfo.SamplerStates.Add(sampler.name, sampler);
        
        	return null;
        }


    }
    
    #endregion ParseTree
}

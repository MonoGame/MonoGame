// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168

namespace MonoGame.Effect.TPGParser
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.Code, TokenType.Technique, TokenType.Sampler); // ZeroOrMore Rule
            while (tok.Type == TokenType.Code
                || tok.Type == TokenType.Technique
                || tok.Type == TokenType.Sampler)
            {
                tok = scanner.LookAhead(TokenType.Code, TokenType.Technique, TokenType.Sampler); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.Code:
                        tok = scanner.Scan(TokenType.Code); // Terminal Rule: Code
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.Code) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Code.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.Technique:
                        ParseTechnique_Declaration(node); // NonTerminal Rule: Technique_Declaration
                        break;
                    case TokenType.Sampler:
                        ParseSampler_Declaration(node); // NonTerminal Rule: Sampler_Declaration
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Code, Technique, or Sampler.", 0x0002, tok));
                        break;
                } // Choice Rule
            tok = scanner.LookAhead(TokenType.Code, TokenType.Technique, TokenType.Sampler); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EndOfFile); // Terminal Rule: EndOfFile
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EndOfFile) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EndOfFile.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseTechnique_Declaration(ParseNode parent) // NonTerminalSymbol: Technique_Declaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Technique_Declaration), "Technique_Declaration");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.Technique); // Terminal Rule: Technique
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Technique) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Technique.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Identifier); // Option Rule
            if (tok.Type == TokenType.Identifier)
            {
                tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Identifier) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.OpenBracket); // Terminal Rule: OpenBracket
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenBracket) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenBracket.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            do { // OneOrMore Rule
                ParsePass_Declaration(node); // NonTerminal Rule: Pass_Declaration
                tok = scanner.LookAhead(TokenType.Pass); // OneOrMore Rule
            } while (tok.Type == TokenType.Pass); // OneOrMore Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.CloseBracket); // Terminal Rule: CloseBracket
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseBracket) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseBracket.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Technique_Declaration

        private void ParseFillMode_Solid(ParseNode parent) // NonTerminalSymbol: FillMode_Solid
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FillMode_Solid), "FillMode_Solid");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Solid); // Terminal Rule: Solid
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Solid) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Solid.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FillMode_Solid

        private void ParseFillMode_WireFrame(ParseNode parent) // NonTerminalSymbol: FillMode_WireFrame
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FillMode_WireFrame), "FillMode_WireFrame");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.WireFrame); // Terminal Rule: WireFrame
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WireFrame) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WireFrame.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FillMode_WireFrame

        private void ParseFillModes(ParseNode parent) // NonTerminalSymbol: FillModes
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FillModes), "FillModes");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Solid, TokenType.WireFrame); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Solid:
                    ParseFillMode_Solid(node); // NonTerminal Rule: FillMode_Solid
                    break;
                case TokenType.WireFrame:
                    ParseFillMode_WireFrame(node); // NonTerminal Rule: FillMode_WireFrame
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Solid or WireFrame.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FillModes

        private void ParseCullMode_None(ParseNode parent) // NonTerminalSymbol: CullMode_None
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CullMode_None), "CullMode_None");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.None); // Terminal Rule: None
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.None) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.None.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CullMode_None

        private void ParseCullMode_Cw(ParseNode parent) // NonTerminalSymbol: CullMode_Cw
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CullMode_Cw), "CullMode_Cw");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Cw); // Terminal Rule: Cw
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Cw) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Cw.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CullMode_Cw

        private void ParseCullMode_Ccw(ParseNode parent) // NonTerminalSymbol: CullMode_Ccw
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CullMode_Ccw), "CullMode_Ccw");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Ccw); // Terminal Rule: Ccw
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Ccw) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Ccw.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CullMode_Ccw

        private void ParseCullModes(ParseNode parent) // NonTerminalSymbol: CullModes
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CullModes), "CullModes");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.None, TokenType.Cw, TokenType.Ccw); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.None:
                    ParseCullMode_None(node); // NonTerminal Rule: CullMode_None
                    break;
                case TokenType.Cw:
                    ParseCullMode_Cw(node); // NonTerminal Rule: CullMode_Cw
                    break;
                case TokenType.Ccw:
                    ParseCullMode_Ccw(node); // NonTerminal Rule: CullMode_Ccw
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected None, Cw, or Ccw.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CullModes

        private void ParseColors_None(ParseNode parent) // NonTerminalSymbol: Colors_None
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors_None), "Colors_None");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.None); // Terminal Rule: None
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.None) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.None.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors_None

        private void ParseColors_Red(ParseNode parent) // NonTerminalSymbol: Colors_Red
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors_Red), "Colors_Red");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Red); // Terminal Rule: Red
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Red) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Red.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors_Red

        private void ParseColors_Green(ParseNode parent) // NonTerminalSymbol: Colors_Green
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors_Green), "Colors_Green");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Green); // Terminal Rule: Green
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Green) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Green.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors_Green

        private void ParseColors_Blue(ParseNode parent) // NonTerminalSymbol: Colors_Blue
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors_Blue), "Colors_Blue");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Blue); // Terminal Rule: Blue
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Blue) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Blue.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors_Blue

        private void ParseColors_Alpha(ParseNode parent) // NonTerminalSymbol: Colors_Alpha
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors_Alpha), "Colors_Alpha");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Alpha); // Terminal Rule: Alpha
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Alpha) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Alpha.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors_Alpha

        private void ParseColors_All(ParseNode parent) // NonTerminalSymbol: Colors_All
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors_All), "Colors_All");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.All); // Terminal Rule: All
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.All) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.All.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors_All

        private void ParseColors_Boolean(ParseNode parent) // NonTerminalSymbol: Colors_Boolean
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors_Boolean), "Colors_Boolean");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Boolean); // Terminal Rule: Boolean
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Boolean) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Boolean.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors_Boolean

        private void ParseColors(ParseNode parent) // NonTerminalSymbol: Colors
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Colors), "Colors");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Red, TokenType.Green, TokenType.Blue, TokenType.Alpha, TokenType.None, TokenType.All, TokenType.Boolean); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Red:
                    ParseColors_Red(node); // NonTerminal Rule: Colors_Red
                    break;
                case TokenType.Green:
                    ParseColors_Green(node); // NonTerminal Rule: Colors_Green
                    break;
                case TokenType.Blue:
                    ParseColors_Blue(node); // NonTerminal Rule: Colors_Blue
                    break;
                case TokenType.Alpha:
                    ParseColors_Alpha(node); // NonTerminal Rule: Colors_Alpha
                    break;
                case TokenType.None:
                    ParseColors_None(node); // NonTerminal Rule: Colors_None
                    break;
                case TokenType.All:
                    ParseColors_All(node); // NonTerminal Rule: Colors_All
                    break;
                case TokenType.Boolean:
                    ParseColors_Boolean(node); // NonTerminal Rule: Colors_Boolean
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Red, Green, Blue, Alpha, None, All, or Boolean.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Colors

        private void ParseColorsMasks(ParseNode parent) // NonTerminalSymbol: ColorsMasks
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ColorsMasks), "ColorsMasks");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseColors(node); // NonTerminal Rule: Colors

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Or); // Option Rule
            if (tok.Type == TokenType.Or)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.Or); // Terminal Rule: Or
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Or) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Or.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseColors(node); // NonTerminal Rule: Colors
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Or); // Option Rule
            if (tok.Type == TokenType.Or)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.Or); // Terminal Rule: Or
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Or) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Or.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseColors(node); // NonTerminal Rule: Colors
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Or); // Option Rule
            if (tok.Type == TokenType.Or)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.Or); // Terminal Rule: Or
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Or) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Or.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseColors(node); // NonTerminal Rule: Colors
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ColorsMasks

        private void ParseBlend_Zero(ParseNode parent) // NonTerminalSymbol: Blend_Zero
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_Zero), "Blend_Zero");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Zero); // Terminal Rule: Zero
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Zero) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Zero.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_Zero

        private void ParseBlend_One(ParseNode parent) // NonTerminalSymbol: Blend_One
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_One), "Blend_One");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.One); // Terminal Rule: One
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.One) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.One.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_One

        private void ParseBlend_SrcColor(ParseNode parent) // NonTerminalSymbol: Blend_SrcColor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_SrcColor), "Blend_SrcColor");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.SrcColor); // Terminal Rule: SrcColor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SrcColor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SrcColor.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_SrcColor

        private void ParseBlend_InvSrcColor(ParseNode parent) // NonTerminalSymbol: Blend_InvSrcColor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_InvSrcColor), "Blend_InvSrcColor");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.InvSrcColor); // Terminal Rule: InvSrcColor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.InvSrcColor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.InvSrcColor.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_InvSrcColor

        private void ParseBlend_SrcAlpha(ParseNode parent) // NonTerminalSymbol: Blend_SrcAlpha
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_SrcAlpha), "Blend_SrcAlpha");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.SrcAlpha); // Terminal Rule: SrcAlpha
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SrcAlpha) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SrcAlpha.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_SrcAlpha

        private void ParseBlend_InvSrcAlpha(ParseNode parent) // NonTerminalSymbol: Blend_InvSrcAlpha
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_InvSrcAlpha), "Blend_InvSrcAlpha");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.InvSrcAlpha); // Terminal Rule: InvSrcAlpha
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.InvSrcAlpha) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.InvSrcAlpha.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_InvSrcAlpha

        private void ParseBlend_DestAlpha(ParseNode parent) // NonTerminalSymbol: Blend_DestAlpha
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_DestAlpha), "Blend_DestAlpha");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.DestAlpha); // Terminal Rule: DestAlpha
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DestAlpha) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DestAlpha.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_DestAlpha

        private void ParseBlend_InvDestAlpha(ParseNode parent) // NonTerminalSymbol: Blend_InvDestAlpha
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_InvDestAlpha), "Blend_InvDestAlpha");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.InvDestAlpha); // Terminal Rule: InvDestAlpha
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.InvDestAlpha) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.InvDestAlpha.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_InvDestAlpha

        private void ParseBlend_DestColor(ParseNode parent) // NonTerminalSymbol: Blend_DestColor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_DestColor), "Blend_DestColor");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.DestColor); // Terminal Rule: DestColor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DestColor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DestColor.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_DestColor

        private void ParseBlend_InvDestColor(ParseNode parent) // NonTerminalSymbol: Blend_InvDestColor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_InvDestColor), "Blend_InvDestColor");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.InvDestColor); // Terminal Rule: InvDestColor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.InvDestColor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.InvDestColor.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_InvDestColor

        private void ParseBlend_SrcAlphaSat(ParseNode parent) // NonTerminalSymbol: Blend_SrcAlphaSat
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_SrcAlphaSat), "Blend_SrcAlphaSat");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.SrcAlphaSat); // Terminal Rule: SrcAlphaSat
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SrcAlphaSat) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SrcAlphaSat.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_SrcAlphaSat

        private void ParseBlend_BlendFactor(ParseNode parent) // NonTerminalSymbol: Blend_BlendFactor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_BlendFactor), "Blend_BlendFactor");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.BlendFactor); // Terminal Rule: BlendFactor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BlendFactor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BlendFactor.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_BlendFactor

        private void ParseBlend_InvBlendFactor(ParseNode parent) // NonTerminalSymbol: Blend_InvBlendFactor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blend_InvBlendFactor), "Blend_InvBlendFactor");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.InvBlendFactor); // Terminal Rule: InvBlendFactor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.InvBlendFactor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.InvBlendFactor.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blend_InvBlendFactor

        private void ParseBlends(ParseNode parent) // NonTerminalSymbol: Blends
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Blends), "Blends");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Zero, TokenType.One, TokenType.SrcColor, TokenType.InvSrcColor, TokenType.SrcAlpha, TokenType.InvSrcAlpha, TokenType.DestAlpha, TokenType.InvDestAlpha, TokenType.DestColor, TokenType.InvDestColor, TokenType.SrcAlphaSat, TokenType.BlendFactor, TokenType.InvBlendFactor); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Zero:
                    ParseBlend_Zero(node); // NonTerminal Rule: Blend_Zero
                    break;
                case TokenType.One:
                    ParseBlend_One(node); // NonTerminal Rule: Blend_One
                    break;
                case TokenType.SrcColor:
                    ParseBlend_SrcColor(node); // NonTerminal Rule: Blend_SrcColor
                    break;
                case TokenType.InvSrcColor:
                    ParseBlend_InvSrcColor(node); // NonTerminal Rule: Blend_InvSrcColor
                    break;
                case TokenType.SrcAlpha:
                    ParseBlend_SrcAlpha(node); // NonTerminal Rule: Blend_SrcAlpha
                    break;
                case TokenType.InvSrcAlpha:
                    ParseBlend_InvSrcAlpha(node); // NonTerminal Rule: Blend_InvSrcAlpha
                    break;
                case TokenType.DestAlpha:
                    ParseBlend_DestAlpha(node); // NonTerminal Rule: Blend_DestAlpha
                    break;
                case TokenType.InvDestAlpha:
                    ParseBlend_InvDestAlpha(node); // NonTerminal Rule: Blend_InvDestAlpha
                    break;
                case TokenType.DestColor:
                    ParseBlend_DestColor(node); // NonTerminal Rule: Blend_DestColor
                    break;
                case TokenType.InvDestColor:
                    ParseBlend_InvDestColor(node); // NonTerminal Rule: Blend_InvDestColor
                    break;
                case TokenType.SrcAlphaSat:
                    ParseBlend_SrcAlphaSat(node); // NonTerminal Rule: Blend_SrcAlphaSat
                    break;
                case TokenType.BlendFactor:
                    ParseBlend_BlendFactor(node); // NonTerminal Rule: Blend_BlendFactor
                    break;
                case TokenType.InvBlendFactor:
                    ParseBlend_InvBlendFactor(node); // NonTerminal Rule: Blend_InvBlendFactor
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Zero, One, SrcColor, InvSrcColor, SrcAlpha, InvSrcAlpha, DestAlpha, InvDestAlpha, DestColor, InvDestColor, SrcAlphaSat, BlendFactor, or InvBlendFactor.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Blends

        private void ParseBlendOp_Add(ParseNode parent) // NonTerminalSymbol: BlendOp_Add
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BlendOp_Add), "BlendOp_Add");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Add); // Terminal Rule: Add
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Add) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Add.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BlendOp_Add

        private void ParseBlendOp_Subtract(ParseNode parent) // NonTerminalSymbol: BlendOp_Subtract
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BlendOp_Subtract), "BlendOp_Subtract");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Subtract); // Terminal Rule: Subtract
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Subtract) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Subtract.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BlendOp_Subtract

        private void ParseBlendOp_RevSubtract(ParseNode parent) // NonTerminalSymbol: BlendOp_RevSubtract
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BlendOp_RevSubtract), "BlendOp_RevSubtract");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.RevSubtract); // Terminal Rule: RevSubtract
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RevSubtract) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RevSubtract.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BlendOp_RevSubtract

        private void ParseBlendOp_Min(ParseNode parent) // NonTerminalSymbol: BlendOp_Min
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BlendOp_Min), "BlendOp_Min");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Min); // Terminal Rule: Min
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Min) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Min.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BlendOp_Min

        private void ParseBlendOp_Max(ParseNode parent) // NonTerminalSymbol: BlendOp_Max
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BlendOp_Max), "BlendOp_Max");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Max); // Terminal Rule: Max
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Max) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Max.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BlendOp_Max

        private void ParseBlendOps(ParseNode parent) // NonTerminalSymbol: BlendOps
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BlendOps), "BlendOps");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Add, TokenType.Subtract, TokenType.RevSubtract, TokenType.Min, TokenType.Max); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Add:
                    ParseBlendOp_Add(node); // NonTerminal Rule: BlendOp_Add
                    break;
                case TokenType.Subtract:
                    ParseBlendOp_Subtract(node); // NonTerminal Rule: BlendOp_Subtract
                    break;
                case TokenType.RevSubtract:
                    ParseBlendOp_RevSubtract(node); // NonTerminal Rule: BlendOp_RevSubtract
                    break;
                case TokenType.Min:
                    ParseBlendOp_Min(node); // NonTerminal Rule: BlendOp_Min
                    break;
                case TokenType.Max:
                    ParseBlendOp_Max(node); // NonTerminal Rule: BlendOp_Max
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Add, Subtract, RevSubtract, Min, or Max.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: BlendOps

        private void ParseCmpFunc_Never(ParseNode parent) // NonTerminalSymbol: CmpFunc_Never
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_Never), "CmpFunc_Never");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Never); // Terminal Rule: Never
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Never) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Never.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_Never

        private void ParseCmpFunc_Less(ParseNode parent) // NonTerminalSymbol: CmpFunc_Less
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_Less), "CmpFunc_Less");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Less); // Terminal Rule: Less
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Less) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Less.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_Less

        private void ParseCmpFunc_Equal(ParseNode parent) // NonTerminalSymbol: CmpFunc_Equal
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_Equal), "CmpFunc_Equal");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Equal); // Terminal Rule: Equal
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equal) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equal.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_Equal

        private void ParseCmpFunc_LessEqual(ParseNode parent) // NonTerminalSymbol: CmpFunc_LessEqual
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_LessEqual), "CmpFunc_LessEqual");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.LessEqual); // Terminal Rule: LessEqual
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LessEqual) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LessEqual.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_LessEqual

        private void ParseCmpFunc_Greater(ParseNode parent) // NonTerminalSymbol: CmpFunc_Greater
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_Greater), "CmpFunc_Greater");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Greater); // Terminal Rule: Greater
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Greater) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Greater.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_Greater

        private void ParseCmpFunc_NotEqual(ParseNode parent) // NonTerminalSymbol: CmpFunc_NotEqual
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_NotEqual), "CmpFunc_NotEqual");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.NotEqual); // Terminal Rule: NotEqual
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NotEqual) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NotEqual.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_NotEqual

        private void ParseCmpFunc_GreaterEqual(ParseNode parent) // NonTerminalSymbol: CmpFunc_GreaterEqual
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_GreaterEqual), "CmpFunc_GreaterEqual");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.GreaterEqual); // Terminal Rule: GreaterEqual
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.GreaterEqual) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GreaterEqual.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_GreaterEqual

        private void ParseCmpFunc_Always(ParseNode parent) // NonTerminalSymbol: CmpFunc_Always
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc_Always), "CmpFunc_Always");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Always); // Terminal Rule: Always
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Always) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Always.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc_Always

        private void ParseCmpFunc(ParseNode parent) // NonTerminalSymbol: CmpFunc
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CmpFunc), "CmpFunc");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Never, TokenType.Less, TokenType.Equal, TokenType.LessEqual, TokenType.Greater, TokenType.NotEqual, TokenType.GreaterEqual, TokenType.Always); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Never:
                    ParseCmpFunc_Never(node); // NonTerminal Rule: CmpFunc_Never
                    break;
                case TokenType.Less:
                    ParseCmpFunc_Less(node); // NonTerminal Rule: CmpFunc_Less
                    break;
                case TokenType.Equal:
                    ParseCmpFunc_Equal(node); // NonTerminal Rule: CmpFunc_Equal
                    break;
                case TokenType.LessEqual:
                    ParseCmpFunc_LessEqual(node); // NonTerminal Rule: CmpFunc_LessEqual
                    break;
                case TokenType.Greater:
                    ParseCmpFunc_Greater(node); // NonTerminal Rule: CmpFunc_Greater
                    break;
                case TokenType.NotEqual:
                    ParseCmpFunc_NotEqual(node); // NonTerminal Rule: CmpFunc_NotEqual
                    break;
                case TokenType.GreaterEqual:
                    ParseCmpFunc_GreaterEqual(node); // NonTerminal Rule: CmpFunc_GreaterEqual
                    break;
                case TokenType.Always:
                    ParseCmpFunc_Always(node); // NonTerminal Rule: CmpFunc_Always
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Never, Less, Equal, LessEqual, Greater, NotEqual, GreaterEqual, or Always.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CmpFunc

        private void ParseStencilOp_Keep(ParseNode parent) // NonTerminalSymbol: StencilOp_Keep
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_Keep), "StencilOp_Keep");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Keep); // Terminal Rule: Keep
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Keep) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Keep.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_Keep

        private void ParseStencilOp_Zero(ParseNode parent) // NonTerminalSymbol: StencilOp_Zero
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_Zero), "StencilOp_Zero");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Zero); // Terminal Rule: Zero
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Zero) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Zero.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_Zero

        private void ParseStencilOp_Replace(ParseNode parent) // NonTerminalSymbol: StencilOp_Replace
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_Replace), "StencilOp_Replace");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Replace); // Terminal Rule: Replace
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Replace) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Replace.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_Replace

        private void ParseStencilOp_IncrSat(ParseNode parent) // NonTerminalSymbol: StencilOp_IncrSat
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_IncrSat), "StencilOp_IncrSat");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.IncrSat); // Terminal Rule: IncrSat
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IncrSat) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IncrSat.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_IncrSat

        private void ParseStencilOp_DecrSat(ParseNode parent) // NonTerminalSymbol: StencilOp_DecrSat
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_DecrSat), "StencilOp_DecrSat");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.DecrSat); // Terminal Rule: DecrSat
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DecrSat) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DecrSat.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_DecrSat

        private void ParseStencilOp_Invert(ParseNode parent) // NonTerminalSymbol: StencilOp_Invert
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_Invert), "StencilOp_Invert");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Invert); // Terminal Rule: Invert
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Invert) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Invert.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_Invert

        private void ParseStencilOp_Incr(ParseNode parent) // NonTerminalSymbol: StencilOp_Incr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_Incr), "StencilOp_Incr");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Incr); // Terminal Rule: Incr
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Incr) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Incr.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_Incr

        private void ParseStencilOp_Decr(ParseNode parent) // NonTerminalSymbol: StencilOp_Decr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp_Decr), "StencilOp_Decr");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Decr); // Terminal Rule: Decr
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Decr) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Decr.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp_Decr

        private void ParseStencilOp(ParseNode parent) // NonTerminalSymbol: StencilOp
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StencilOp), "StencilOp");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Keep, TokenType.Zero, TokenType.Replace, TokenType.IncrSat, TokenType.DecrSat, TokenType.Invert, TokenType.Incr, TokenType.Decr); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Keep:
                    ParseStencilOp_Keep(node); // NonTerminal Rule: StencilOp_Keep
                    break;
                case TokenType.Zero:
                    ParseStencilOp_Zero(node); // NonTerminal Rule: StencilOp_Zero
                    break;
                case TokenType.Replace:
                    ParseStencilOp_Replace(node); // NonTerminal Rule: StencilOp_Replace
                    break;
                case TokenType.IncrSat:
                    ParseStencilOp_IncrSat(node); // NonTerminal Rule: StencilOp_IncrSat
                    break;
                case TokenType.DecrSat:
                    ParseStencilOp_DecrSat(node); // NonTerminal Rule: StencilOp_DecrSat
                    break;
                case TokenType.Invert:
                    ParseStencilOp_Invert(node); // NonTerminal Rule: StencilOp_Invert
                    break;
                case TokenType.Incr:
                    ParseStencilOp_Incr(node); // NonTerminal Rule: StencilOp_Incr
                    break;
                case TokenType.Decr:
                    ParseStencilOp_Decr(node); // NonTerminal Rule: StencilOp_Decr
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Keep, Zero, Replace, IncrSat, DecrSat, Invert, Incr, or Decr.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: StencilOp

        private void ParseRender_State_CullMode(ParseNode parent) // NonTerminalSymbol: Render_State_CullMode
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_CullMode), "Render_State_CullMode");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CullMode); // Terminal Rule: CullMode
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CullMode) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CullMode.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCullModes(node); // NonTerminal Rule: CullModes

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_CullMode

        private void ParseRender_State_FillMode(ParseNode parent) // NonTerminalSymbol: Render_State_FillMode
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_FillMode), "Render_State_FillMode");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FillMode); // Terminal Rule: FillMode
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FillMode) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FillMode.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseFillModes(node); // NonTerminal Rule: FillModes

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_FillMode

        private void ParseRender_State_AlphaBlendEnable(ParseNode parent) // NonTerminalSymbol: Render_State_AlphaBlendEnable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_AlphaBlendEnable), "Render_State_AlphaBlendEnable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.AlphaBlendEnable); // Terminal Rule: AlphaBlendEnable
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.AlphaBlendEnable) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AlphaBlendEnable.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Boolean); // Terminal Rule: Boolean
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Boolean) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Boolean.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_AlphaBlendEnable

        private void ParseRender_State_SrcBlend(ParseNode parent) // NonTerminalSymbol: Render_State_SrcBlend
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_SrcBlend), "Render_State_SrcBlend");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SrcBlend); // Terminal Rule: SrcBlend
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SrcBlend) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SrcBlend.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseBlends(node); // NonTerminal Rule: Blends

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_SrcBlend

        private void ParseRender_State_DestBlend(ParseNode parent) // NonTerminalSymbol: Render_State_DestBlend
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_DestBlend), "Render_State_DestBlend");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.DestBlend); // Terminal Rule: DestBlend
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DestBlend) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DestBlend.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseBlends(node); // NonTerminal Rule: Blends

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_DestBlend

        private void ParseRender_State_BlendOp(ParseNode parent) // NonTerminalSymbol: Render_State_BlendOp
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_BlendOp), "Render_State_BlendOp");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BlendOp); // Terminal Rule: BlendOp
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BlendOp) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BlendOp.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseBlendOps(node); // NonTerminal Rule: BlendOps

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_BlendOp

        private void ParseRender_State_ColorWriteEnable(ParseNode parent) // NonTerminalSymbol: Render_State_ColorWriteEnable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_ColorWriteEnable), "Render_State_ColorWriteEnable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ColorWriteEnable); // Terminal Rule: ColorWriteEnable
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ColorWriteEnable) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ColorWriteEnable.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseColorsMasks(node); // NonTerminal Rule: ColorsMasks

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_ColorWriteEnable

        private void ParseRender_State_DepthBias(ParseNode parent) // NonTerminalSymbol: Render_State_DepthBias
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_DepthBias), "Render_State_DepthBias");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.DepthBias); // Terminal Rule: DepthBias
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DepthBias) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DepthBias.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_DepthBias

        private void ParseRender_State_SlopeScaleDepthBias(ParseNode parent) // NonTerminalSymbol: Render_State_SlopeScaleDepthBias
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_SlopeScaleDepthBias), "Render_State_SlopeScaleDepthBias");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SlopeScaleDepthBias); // Terminal Rule: SlopeScaleDepthBias
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SlopeScaleDepthBias) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SlopeScaleDepthBias.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_SlopeScaleDepthBias

        private void ParseRender_State_ZEnable(ParseNode parent) // NonTerminalSymbol: Render_State_ZEnable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_ZEnable), "Render_State_ZEnable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ZEnable); // Terminal Rule: ZEnable
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ZEnable) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ZEnable.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Boolean); // Terminal Rule: Boolean
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Boolean) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Boolean.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_ZEnable

        private void ParseRender_State_ZWriteEnable(ParseNode parent) // NonTerminalSymbol: Render_State_ZWriteEnable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_ZWriteEnable), "Render_State_ZWriteEnable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ZWriteEnable); // Terminal Rule: ZWriteEnable
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ZWriteEnable) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ZWriteEnable.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Boolean); // Terminal Rule: Boolean
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Boolean) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Boolean.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_ZWriteEnable

        private void ParseRender_State_ZFunc(ParseNode parent) // NonTerminalSymbol: Render_State_ZFunc
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_ZFunc), "Render_State_ZFunc");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ZFunc); // Terminal Rule: ZFunc
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ZFunc) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ZFunc.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCmpFunc(node); // NonTerminal Rule: CmpFunc

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_ZFunc

        private void ParseRender_State_MultiSampleAntiAlias(ParseNode parent) // NonTerminalSymbol: Render_State_MultiSampleAntiAlias
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_MultiSampleAntiAlias), "Render_State_MultiSampleAntiAlias");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.MultiSampleAntiAlias); // Terminal Rule: MultiSampleAntiAlias
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MultiSampleAntiAlias) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MultiSampleAntiAlias.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Boolean); // Terminal Rule: Boolean
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Boolean) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Boolean.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_MultiSampleAntiAlias

        private void ParseRender_State_ScissorTestEnable(ParseNode parent) // NonTerminalSymbol: Render_State_ScissorTestEnable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_ScissorTestEnable), "Render_State_ScissorTestEnable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ScissorTestEnable); // Terminal Rule: ScissorTestEnable
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ScissorTestEnable) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ScissorTestEnable.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Boolean); // Terminal Rule: Boolean
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Boolean) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Boolean.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_ScissorTestEnable

        private void ParseRender_State_StencilEnable(ParseNode parent) // NonTerminalSymbol: Render_State_StencilEnable
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilEnable), "Render_State_StencilEnable");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilEnable); // Terminal Rule: StencilEnable
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilEnable) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilEnable.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Boolean); // Terminal Rule: Boolean
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Boolean) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Boolean.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilEnable

        private void ParseRender_State_StencilFail(ParseNode parent) // NonTerminalSymbol: Render_State_StencilFail
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilFail), "Render_State_StencilFail");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilFail); // Terminal Rule: StencilFail
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilFail) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilFail.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseStencilOp(node); // NonTerminal Rule: StencilOp

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilFail

        private void ParseRender_State_StencilFunc(ParseNode parent) // NonTerminalSymbol: Render_State_StencilFunc
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilFunc), "Render_State_StencilFunc");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilFunc); // Terminal Rule: StencilFunc
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilFunc) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilFunc.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCmpFunc(node); // NonTerminal Rule: CmpFunc

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilFunc

        private void ParseRender_State_StencilMask(ParseNode parent) // NonTerminalSymbol: Render_State_StencilMask
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilMask), "Render_State_StencilMask");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilMask); // Terminal Rule: StencilMask
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilMask) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilMask.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilMask

        private void ParseRender_State_StencilPass(ParseNode parent) // NonTerminalSymbol: Render_State_StencilPass
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilPass), "Render_State_StencilPass");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilPass); // Terminal Rule: StencilPass
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilPass) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilPass.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseStencilOp(node); // NonTerminal Rule: StencilOp

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilPass

        private void ParseRender_State_StencilRef(ParseNode parent) // NonTerminalSymbol: Render_State_StencilRef
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilRef), "Render_State_StencilRef");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilRef); // Terminal Rule: StencilRef
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilRef) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilRef.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilRef

        private void ParseRender_State_StencilWriteMask(ParseNode parent) // NonTerminalSymbol: Render_State_StencilWriteMask
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilWriteMask), "Render_State_StencilWriteMask");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilWriteMask); // Terminal Rule: StencilWriteMask
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilWriteMask) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilWriteMask.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilWriteMask

        private void ParseRender_State_StencilZFail(ParseNode parent) // NonTerminalSymbol: Render_State_StencilZFail
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_StencilZFail), "Render_State_StencilZFail");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.StencilZFail); // Terminal Rule: StencilZFail
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.StencilZFail) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.StencilZFail.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseStencilOp(node); // NonTerminal Rule: StencilOp

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_StencilZFail

        private void ParseRender_State_Expression(ParseNode parent) // NonTerminalSymbol: Render_State_Expression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Render_State_Expression), "Render_State_Expression");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.CullMode, TokenType.FillMode, TokenType.AlphaBlendEnable, TokenType.SrcBlend, TokenType.DestBlend, TokenType.BlendOp, TokenType.ColorWriteEnable, TokenType.DepthBias, TokenType.SlopeScaleDepthBias, TokenType.ZEnable, TokenType.ZWriteEnable, TokenType.ZFunc, TokenType.MultiSampleAntiAlias, TokenType.ScissorTestEnable, TokenType.StencilEnable, TokenType.StencilFail, TokenType.StencilFunc, TokenType.StencilMask, TokenType.StencilPass, TokenType.StencilRef, TokenType.StencilWriteMask, TokenType.StencilZFail); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.CullMode:
                    ParseRender_State_CullMode(node); // NonTerminal Rule: Render_State_CullMode
                    break;
                case TokenType.FillMode:
                    ParseRender_State_FillMode(node); // NonTerminal Rule: Render_State_FillMode
                    break;
                case TokenType.AlphaBlendEnable:
                    ParseRender_State_AlphaBlendEnable(node); // NonTerminal Rule: Render_State_AlphaBlendEnable
                    break;
                case TokenType.SrcBlend:
                    ParseRender_State_SrcBlend(node); // NonTerminal Rule: Render_State_SrcBlend
                    break;
                case TokenType.DestBlend:
                    ParseRender_State_DestBlend(node); // NonTerminal Rule: Render_State_DestBlend
                    break;
                case TokenType.BlendOp:
                    ParseRender_State_BlendOp(node); // NonTerminal Rule: Render_State_BlendOp
                    break;
                case TokenType.ColorWriteEnable:
                    ParseRender_State_ColorWriteEnable(node); // NonTerminal Rule: Render_State_ColorWriteEnable
                    break;
                case TokenType.DepthBias:
                    ParseRender_State_DepthBias(node); // NonTerminal Rule: Render_State_DepthBias
                    break;
                case TokenType.SlopeScaleDepthBias:
                    ParseRender_State_SlopeScaleDepthBias(node); // NonTerminal Rule: Render_State_SlopeScaleDepthBias
                    break;
                case TokenType.ZEnable:
                    ParseRender_State_ZEnable(node); // NonTerminal Rule: Render_State_ZEnable
                    break;
                case TokenType.ZWriteEnable:
                    ParseRender_State_ZWriteEnable(node); // NonTerminal Rule: Render_State_ZWriteEnable
                    break;
                case TokenType.ZFunc:
                    ParseRender_State_ZFunc(node); // NonTerminal Rule: Render_State_ZFunc
                    break;
                case TokenType.MultiSampleAntiAlias:
                    ParseRender_State_MultiSampleAntiAlias(node); // NonTerminal Rule: Render_State_MultiSampleAntiAlias
                    break;
                case TokenType.ScissorTestEnable:
                    ParseRender_State_ScissorTestEnable(node); // NonTerminal Rule: Render_State_ScissorTestEnable
                    break;
                case TokenType.StencilEnable:
                    ParseRender_State_StencilEnable(node); // NonTerminal Rule: Render_State_StencilEnable
                    break;
                case TokenType.StencilFail:
                    ParseRender_State_StencilFail(node); // NonTerminal Rule: Render_State_StencilFail
                    break;
                case TokenType.StencilFunc:
                    ParseRender_State_StencilFunc(node); // NonTerminal Rule: Render_State_StencilFunc
                    break;
                case TokenType.StencilMask:
                    ParseRender_State_StencilMask(node); // NonTerminal Rule: Render_State_StencilMask
                    break;
                case TokenType.StencilPass:
                    ParseRender_State_StencilPass(node); // NonTerminal Rule: Render_State_StencilPass
                    break;
                case TokenType.StencilRef:
                    ParseRender_State_StencilRef(node); // NonTerminal Rule: Render_State_StencilRef
                    break;
                case TokenType.StencilWriteMask:
                    ParseRender_State_StencilWriteMask(node); // NonTerminal Rule: Render_State_StencilWriteMask
                    break;
                case TokenType.StencilZFail:
                    ParseRender_State_StencilZFail(node); // NonTerminal Rule: Render_State_StencilZFail
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected CullMode, FillMode, AlphaBlendEnable, SrcBlend, DestBlend, BlendOp, ColorWriteEnable, DepthBias, SlopeScaleDepthBias, ZEnable, ZWriteEnable, ZFunc, MultiSampleAntiAlias, ScissorTestEnable, StencilEnable, StencilFail, StencilFunc, StencilMask, StencilPass, StencilRef, StencilWriteMask, or StencilZFail.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Render_State_Expression

        private void ParsePass_Declaration(ParseNode parent) // NonTerminalSymbol: Pass_Declaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Pass_Declaration), "Pass_Declaration");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.Pass); // Terminal Rule: Pass
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Pass) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Pass.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Identifier); // Option Rule
            if (tok.Type == TokenType.Identifier)
            {
                tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Identifier) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.OpenBracket); // Terminal Rule: OpenBracket
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenBracket) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenBracket.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.VertexShader, TokenType.PixelShader, TokenType.CullMode, TokenType.FillMode, TokenType.AlphaBlendEnable, TokenType.SrcBlend, TokenType.DestBlend, TokenType.BlendOp, TokenType.ColorWriteEnable, TokenType.DepthBias, TokenType.SlopeScaleDepthBias, TokenType.ZEnable, TokenType.ZWriteEnable, TokenType.ZFunc, TokenType.MultiSampleAntiAlias, TokenType.ScissorTestEnable, TokenType.StencilEnable, TokenType.StencilFail, TokenType.StencilFunc, TokenType.StencilMask, TokenType.StencilPass, TokenType.StencilRef, TokenType.StencilWriteMask, TokenType.StencilZFail); // ZeroOrMore Rule
            while (tok.Type == TokenType.VertexShader
                || tok.Type == TokenType.PixelShader
                || tok.Type == TokenType.CullMode
                || tok.Type == TokenType.FillMode
                || tok.Type == TokenType.AlphaBlendEnable
                || tok.Type == TokenType.SrcBlend
                || tok.Type == TokenType.DestBlend
                || tok.Type == TokenType.BlendOp
                || tok.Type == TokenType.ColorWriteEnable
                || tok.Type == TokenType.DepthBias
                || tok.Type == TokenType.SlopeScaleDepthBias
                || tok.Type == TokenType.ZEnable
                || tok.Type == TokenType.ZWriteEnable
                || tok.Type == TokenType.ZFunc
                || tok.Type == TokenType.MultiSampleAntiAlias
                || tok.Type == TokenType.ScissorTestEnable
                || tok.Type == TokenType.StencilEnable
                || tok.Type == TokenType.StencilFail
                || tok.Type == TokenType.StencilFunc
                || tok.Type == TokenType.StencilMask
                || tok.Type == TokenType.StencilPass
                || tok.Type == TokenType.StencilRef
                || tok.Type == TokenType.StencilWriteMask
                || tok.Type == TokenType.StencilZFail)
            {
                tok = scanner.LookAhead(TokenType.VertexShader, TokenType.PixelShader, TokenType.CullMode, TokenType.FillMode, TokenType.AlphaBlendEnable, TokenType.SrcBlend, TokenType.DestBlend, TokenType.BlendOp, TokenType.ColorWriteEnable, TokenType.DepthBias, TokenType.SlopeScaleDepthBias, TokenType.ZEnable, TokenType.ZWriteEnable, TokenType.ZFunc, TokenType.MultiSampleAntiAlias, TokenType.ScissorTestEnable, TokenType.StencilEnable, TokenType.StencilFail, TokenType.StencilFunc, TokenType.StencilMask, TokenType.StencilPass, TokenType.StencilRef, TokenType.StencilWriteMask, TokenType.StencilZFail); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.VertexShader:
                        ParseVertexShader_Pass_Expression(node); // NonTerminal Rule: VertexShader_Pass_Expression
                        break;
                    case TokenType.PixelShader:
                        ParsePixelShader_Pass_Expression(node); // NonTerminal Rule: PixelShader_Pass_Expression
                        break;
                    case TokenType.CullMode:
                    case TokenType.FillMode:
                    case TokenType.AlphaBlendEnable:
                    case TokenType.SrcBlend:
                    case TokenType.DestBlend:
                    case TokenType.BlendOp:
                    case TokenType.ColorWriteEnable:
                    case TokenType.DepthBias:
                    case TokenType.SlopeScaleDepthBias:
                    case TokenType.ZEnable:
                    case TokenType.ZWriteEnable:
                    case TokenType.ZFunc:
                    case TokenType.MultiSampleAntiAlias:
                    case TokenType.ScissorTestEnable:
                    case TokenType.StencilEnable:
                    case TokenType.StencilFail:
                    case TokenType.StencilFunc:
                    case TokenType.StencilMask:
                    case TokenType.StencilPass:
                    case TokenType.StencilRef:
                    case TokenType.StencilWriteMask:
                    case TokenType.StencilZFail:
                        ParseRender_State_Expression(node); // NonTerminal Rule: Render_State_Expression
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected VertexShader, PixelShader, CullMode, FillMode, AlphaBlendEnable, SrcBlend, DestBlend, BlendOp, ColorWriteEnable, DepthBias, SlopeScaleDepthBias, ZEnable, ZWriteEnable, ZFunc, MultiSampleAntiAlias, ScissorTestEnable, StencilEnable, StencilFail, StencilFunc, StencilMask, StencilPass, StencilRef, StencilWriteMask, or StencilZFail.", 0x0002, tok));
                        break;
                } // Choice Rule
            tok = scanner.LookAhead(TokenType.VertexShader, TokenType.PixelShader, TokenType.CullMode, TokenType.FillMode, TokenType.AlphaBlendEnable, TokenType.SrcBlend, TokenType.DestBlend, TokenType.BlendOp, TokenType.ColorWriteEnable, TokenType.DepthBias, TokenType.SlopeScaleDepthBias, TokenType.ZEnable, TokenType.ZWriteEnable, TokenType.ZFunc, TokenType.MultiSampleAntiAlias, TokenType.ScissorTestEnable, TokenType.StencilEnable, TokenType.StencilFail, TokenType.StencilFunc, TokenType.StencilMask, TokenType.StencilPass, TokenType.StencilRef, TokenType.StencilWriteMask, TokenType.StencilZFail); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.CloseBracket); // Terminal Rule: CloseBracket
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseBracket) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseBracket.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Pass_Declaration

        private void ParseVertexShader_Pass_Expression(ParseNode parent) // NonTerminalSymbol: VertexShader_Pass_Expression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VertexShader_Pass_Expression), "VertexShader_Pass_Expression");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.VertexShader); // Terminal Rule: VertexShader
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VertexShader) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VertexShader.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Compile); // Terminal Rule: Compile
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Compile) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Compile.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.ShaderModel); // Terminal Rule: ShaderModel
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ShaderModel) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ShaderModel.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Identifier) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.OpenParenthesis); // Terminal Rule: OpenParenthesis
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParenthesis) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParenthesis.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.CloseParenthesis); // Terminal Rule: CloseParenthesis
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParenthesis) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParenthesis.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: VertexShader_Pass_Expression

        private void ParsePixelShader_Pass_Expression(ParseNode parent) // NonTerminalSymbol: PixelShader_Pass_Expression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PixelShader_Pass_Expression), "PixelShader_Pass_Expression");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PixelShader); // Terminal Rule: PixelShader
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PixelShader) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PixelShader.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Compile); // Terminal Rule: Compile
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Compile) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Compile.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.ShaderModel); // Terminal Rule: ShaderModel
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ShaderModel) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ShaderModel.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Identifier) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.OpenParenthesis); // Terminal Rule: OpenParenthesis
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParenthesis) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParenthesis.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.CloseParenthesis); // Terminal Rule: CloseParenthesis
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParenthesis) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParenthesis.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: PixelShader_Pass_Expression

        private void ParseAddressMode_Clamp(ParseNode parent) // NonTerminalSymbol: AddressMode_Clamp
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddressMode_Clamp), "AddressMode_Clamp");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Clamp); // Terminal Rule: Clamp
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Clamp) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Clamp.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddressMode_Clamp

        private void ParseAddressMode_Wrap(ParseNode parent) // NonTerminalSymbol: AddressMode_Wrap
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddressMode_Wrap), "AddressMode_Wrap");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Wrap); // Terminal Rule: Wrap
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Wrap) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Wrap.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddressMode_Wrap

        private void ParseAddressMode_Mirror(ParseNode parent) // NonTerminalSymbol: AddressMode_Mirror
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddressMode_Mirror), "AddressMode_Mirror");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Mirror); // Terminal Rule: Mirror
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Mirror) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Mirror.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddressMode_Mirror

        private void ParseAddressMode_Border(ParseNode parent) // NonTerminalSymbol: AddressMode_Border
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddressMode_Border), "AddressMode_Border");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Border); // Terminal Rule: Border
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Border) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Border.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddressMode_Border

        private void ParseAddressMode(ParseNode parent) // NonTerminalSymbol: AddressMode
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddressMode), "AddressMode");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Clamp, TokenType.Wrap, TokenType.Mirror, TokenType.Border); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Clamp:
                    ParseAddressMode_Clamp(node); // NonTerminal Rule: AddressMode_Clamp
                    break;
                case TokenType.Wrap:
                    ParseAddressMode_Wrap(node); // NonTerminal Rule: AddressMode_Wrap
                    break;
                case TokenType.Mirror:
                    ParseAddressMode_Mirror(node); // NonTerminal Rule: AddressMode_Mirror
                    break;
                case TokenType.Border:
                    ParseAddressMode_Border(node); // NonTerminal Rule: AddressMode_Border
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Clamp, Wrap, Mirror, or Border.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AddressMode

        private void ParseTextureFilter_None(ParseNode parent) // NonTerminalSymbol: TextureFilter_None
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TextureFilter_None), "TextureFilter_None");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.None); // Terminal Rule: None
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.None) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.None.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TextureFilter_None

        private void ParseTextureFilter_Linear(ParseNode parent) // NonTerminalSymbol: TextureFilter_Linear
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TextureFilter_Linear), "TextureFilter_Linear");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Linear); // Terminal Rule: Linear
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Linear) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Linear.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TextureFilter_Linear

        private void ParseTextureFilter_Point(ParseNode parent) // NonTerminalSymbol: TextureFilter_Point
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TextureFilter_Point), "TextureFilter_Point");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Point); // Terminal Rule: Point
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Point) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Point.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TextureFilter_Point

        private void ParseTextureFilter_Anisotropic(ParseNode parent) // NonTerminalSymbol: TextureFilter_Anisotropic
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TextureFilter_Anisotropic), "TextureFilter_Anisotropic");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.Anisotropic); // Terminal Rule: Anisotropic
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Anisotropic) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Anisotropic.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TextureFilter_Anisotropic

        private void ParseTextureFilter(ParseNode parent) // NonTerminalSymbol: TextureFilter
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TextureFilter), "TextureFilter");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.None, TokenType.Linear, TokenType.Point, TokenType.Anisotropic); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.None:
                    ParseTextureFilter_None(node); // NonTerminal Rule: TextureFilter_None
                    break;
                case TokenType.Linear:
                    ParseTextureFilter_Linear(node); // NonTerminal Rule: TextureFilter_Linear
                    break;
                case TokenType.Point:
                    ParseTextureFilter_Point(node); // NonTerminal Rule: TextureFilter_Point
                    break;
                case TokenType.Anisotropic:
                    ParseTextureFilter_Anisotropic(node); // NonTerminal Rule: TextureFilter_Anisotropic
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected None, Linear, Point, or Anisotropic.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: TextureFilter

        private void ParseSampler_State_Texture(ParseNode parent) // NonTerminalSymbol: Sampler_State_Texture
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_Texture), "Sampler_State_Texture");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.Texture); // Terminal Rule: Texture
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Texture) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Texture.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.LessThan, TokenType.OpenParenthesis); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.LessThan:
                    tok = scanner.Scan(TokenType.LessThan); // Terminal Rule: LessThan
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LessThan) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LessThan.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.OpenParenthesis:
                    tok = scanner.Scan(TokenType.OpenParenthesis); // Terminal Rule: OpenParenthesis
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenParenthesis) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParenthesis.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected LessThan or OpenParenthesis.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Identifier) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.GreaterThan, TokenType.CloseParenthesis); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.GreaterThan:
                    tok = scanner.Scan(TokenType.GreaterThan); // Terminal Rule: GreaterThan
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.GreaterThan) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GreaterThan.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.CloseParenthesis:
                    tok = scanner.Scan(TokenType.CloseParenthesis); // Terminal Rule: CloseParenthesis
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParenthesis) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParenthesis.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected GreaterThan or CloseParenthesis.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_Texture

        private void ParseSampler_State_MinFilter(ParseNode parent) // NonTerminalSymbol: Sampler_State_MinFilter
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_MinFilter), "Sampler_State_MinFilter");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.MinFilter); // Terminal Rule: MinFilter
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MinFilter) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MinFilter.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseTextureFilter(node); // NonTerminal Rule: TextureFilter

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_MinFilter

        private void ParseSampler_State_MagFilter(ParseNode parent) // NonTerminalSymbol: Sampler_State_MagFilter
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_MagFilter), "Sampler_State_MagFilter");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.MagFilter); // Terminal Rule: MagFilter
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MagFilter) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MagFilter.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseTextureFilter(node); // NonTerminal Rule: TextureFilter

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_MagFilter

        private void ParseSampler_State_MipFilter(ParseNode parent) // NonTerminalSymbol: Sampler_State_MipFilter
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_MipFilter), "Sampler_State_MipFilter");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.MipFilter); // Terminal Rule: MipFilter
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MipFilter) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MipFilter.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseTextureFilter(node); // NonTerminal Rule: TextureFilter

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_MipFilter

        private void ParseSampler_State_Filter(ParseNode parent) // NonTerminalSymbol: Sampler_State_Filter
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_Filter), "Sampler_State_Filter");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.Filter); // Terminal Rule: Filter
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Filter) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Filter.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseTextureFilter(node); // NonTerminal Rule: TextureFilter

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_Filter

        private void ParseSampler_State_AddressU(ParseNode parent) // NonTerminalSymbol: Sampler_State_AddressU
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_AddressU), "Sampler_State_AddressU");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.AddressU); // Terminal Rule: AddressU
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.AddressU) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AddressU.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseAddressMode(node); // NonTerminal Rule: AddressMode

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_AddressU

        private void ParseSampler_State_AddressV(ParseNode parent) // NonTerminalSymbol: Sampler_State_AddressV
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_AddressV), "Sampler_State_AddressV");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.AddressV); // Terminal Rule: AddressV
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.AddressV) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AddressV.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseAddressMode(node); // NonTerminal Rule: AddressMode

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_AddressV

        private void ParseSampler_State_AddressW(ParseNode parent) // NonTerminalSymbol: Sampler_State_AddressW
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_AddressW), "Sampler_State_AddressW");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.AddressW); // Terminal Rule: AddressW
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.AddressW) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AddressW.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseAddressMode(node); // NonTerminal Rule: AddressMode

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_AddressW

        private void ParseSampler_State_BorderColor(ParseNode parent) // NonTerminalSymbol: Sampler_State_BorderColor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_BorderColor), "Sampler_State_BorderColor");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BorderColor); // Terminal Rule: BorderColor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BorderColor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BorderColor.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.HexColor); // Terminal Rule: HexColor
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.HexColor) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.HexColor.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_BorderColor

        private void ParseSampler_State_MaxMipLevel(ParseNode parent) // NonTerminalSymbol: Sampler_State_MaxMipLevel
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_MaxMipLevel), "Sampler_State_MaxMipLevel");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.MaxMipLevel); // Terminal Rule: MaxMipLevel
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MaxMipLevel) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MaxMipLevel.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_MaxMipLevel

        private void ParseSampler_State_MaxAnisotropy(ParseNode parent) // NonTerminalSymbol: Sampler_State_MaxAnisotropy
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_MaxAnisotropy), "Sampler_State_MaxAnisotropy");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.MaxAnisotropy); // Terminal Rule: MaxAnisotropy
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MaxAnisotropy) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MaxAnisotropy.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_MaxAnisotropy

        private void ParseSampler_State_MipLodBias(ParseNode parent) // NonTerminalSymbol: Sampler_State_MipLodBias
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_MipLodBias), "Sampler_State_MipLodBias");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.MipLodBias); // Terminal Rule: MipLodBias
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MipLodBias) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MipLodBias.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Equals) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Number) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Semicolon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_MipLodBias

        private void ParseSampler_State_Expression(ParseNode parent) // NonTerminalSymbol: Sampler_State_Expression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_State_Expression), "Sampler_State_Expression");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.Texture, TokenType.MinFilter, TokenType.MagFilter, TokenType.MipFilter, TokenType.Filter, TokenType.AddressU, TokenType.AddressV, TokenType.AddressW, TokenType.BorderColor, TokenType.MaxMipLevel, TokenType.MaxAnisotropy, TokenType.MipLodBias); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Texture:
                    ParseSampler_State_Texture(node); // NonTerminal Rule: Sampler_State_Texture
                    break;
                case TokenType.MinFilter:
                    ParseSampler_State_MinFilter(node); // NonTerminal Rule: Sampler_State_MinFilter
                    break;
                case TokenType.MagFilter:
                    ParseSampler_State_MagFilter(node); // NonTerminal Rule: Sampler_State_MagFilter
                    break;
                case TokenType.MipFilter:
                    ParseSampler_State_MipFilter(node); // NonTerminal Rule: Sampler_State_MipFilter
                    break;
                case TokenType.Filter:
                    ParseSampler_State_Filter(node); // NonTerminal Rule: Sampler_State_Filter
                    break;
                case TokenType.AddressU:
                    ParseSampler_State_AddressU(node); // NonTerminal Rule: Sampler_State_AddressU
                    break;
                case TokenType.AddressV:
                    ParseSampler_State_AddressV(node); // NonTerminal Rule: Sampler_State_AddressV
                    break;
                case TokenType.AddressW:
                    ParseSampler_State_AddressW(node); // NonTerminal Rule: Sampler_State_AddressW
                    break;
                case TokenType.BorderColor:
                    ParseSampler_State_BorderColor(node); // NonTerminal Rule: Sampler_State_BorderColor
                    break;
                case TokenType.MaxMipLevel:
                    ParseSampler_State_MaxMipLevel(node); // NonTerminal Rule: Sampler_State_MaxMipLevel
                    break;
                case TokenType.MaxAnisotropy:
                    ParseSampler_State_MaxAnisotropy(node); // NonTerminal Rule: Sampler_State_MaxAnisotropy
                    break;
                case TokenType.MipLodBias:
                    ParseSampler_State_MipLodBias(node); // NonTerminal Rule: Sampler_State_MipLodBias
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Texture, MinFilter, MagFilter, MipFilter, Filter, AddressU, AddressV, AddressW, BorderColor, MaxMipLevel, MaxAnisotropy, or MipLodBias.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_State_Expression

        private void ParseSampler_Register_Expression(ParseNode parent) // NonTerminalSymbol: Sampler_Register_Expression
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_Register_Expression), "Sampler_Register_Expression");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.Colon); // Terminal Rule: Colon
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Colon) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Colon.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Register); // Terminal Rule: Register
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Register) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Register.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.OpenParenthesis); // Terminal Rule: OpenParenthesis
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenParenthesis) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenParenthesis.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Identifier) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Comma); // Option Rule
            if (tok.Type == TokenType.Comma)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.Comma); // Terminal Rule: Comma
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Comma) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Identifier) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.OpenSquareBracket); // Option Rule
                if (tok.Type == TokenType.OpenSquareBracket)
                {

                     // Concat Rule
                    tok = scanner.Scan(TokenType.OpenSquareBracket); // Terminal Rule: OpenSquareBracket
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OpenSquareBracket) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenSquareBracket.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.Number); // Terminal Rule: Number
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Number) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Number.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.CloseSquareBracket); // Terminal Rule: CloseSquareBracket
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseSquareBracket) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseSquareBracket.ToString(), 0x1001, tok));
                        return;
                    }
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.CloseParenthesis); // Terminal Rule: CloseParenthesis
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseParenthesis) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParenthesis.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_Register_Expression

        private void ParseSampler_Declaration_States(ParseNode parent) // NonTerminalSymbol: Sampler_Declaration_States
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_Declaration_States), "Sampler_Declaration_States");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.Equals); // Option Rule
            if (tok.Type == TokenType.Equals)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.Equals); // Terminal Rule: Equals
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.Equals) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Equals.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.SamplerState); // Terminal Rule: SamplerState
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SamplerState) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SamplerState.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.OpenBracket); // Terminal Rule: OpenBracket
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OpenBracket) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OpenBracket.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Texture, TokenType.MinFilter, TokenType.MagFilter, TokenType.MipFilter, TokenType.Filter, TokenType.AddressU, TokenType.AddressV, TokenType.AddressW, TokenType.BorderColor, TokenType.MaxMipLevel, TokenType.MaxAnisotropy, TokenType.MipLodBias); // ZeroOrMore Rule
            while (tok.Type == TokenType.Texture
                || tok.Type == TokenType.MinFilter
                || tok.Type == TokenType.MagFilter
                || tok.Type == TokenType.MipFilter
                || tok.Type == TokenType.Filter
                || tok.Type == TokenType.AddressU
                || tok.Type == TokenType.AddressV
                || tok.Type == TokenType.AddressW
                || tok.Type == TokenType.BorderColor
                || tok.Type == TokenType.MaxMipLevel
                || tok.Type == TokenType.MaxAnisotropy
                || tok.Type == TokenType.MipLodBias)
            {
                ParseSampler_State_Expression(node); // NonTerminal Rule: Sampler_State_Expression
            tok = scanner.LookAhead(TokenType.Texture, TokenType.MinFilter, TokenType.MagFilter, TokenType.MipFilter, TokenType.Filter, TokenType.AddressU, TokenType.AddressV, TokenType.AddressW, TokenType.BorderColor, TokenType.MaxMipLevel, TokenType.MaxAnisotropy, TokenType.MipLodBias); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.CloseBracket); // Terminal Rule: CloseBracket
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CloseBracket) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseBracket.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_Declaration_States

        private void ParseSampler_Declaration(ParseNode parent) // NonTerminalSymbol: Sampler_Declaration
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sampler_Declaration), "Sampler_Declaration");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.Sampler); // Terminal Rule: Sampler
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Sampler) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Sampler.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.Identifier); // Terminal Rule: Identifier
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.Identifier) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Identifier.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Colon); // ZeroOrMore Rule
            while (tok.Type == TokenType.Colon)
            {
                ParseSampler_Register_Expression(node); // NonTerminal Rule: Sampler_Register_Expression
            tok = scanner.LookAhead(TokenType.Colon); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Equals, TokenType.OpenBracket); // Option Rule
            if (tok.Type == TokenType.Equals
                || tok.Type == TokenType.OpenBracket)
            {
                ParseSampler_Declaration_States(node); // NonTerminal Rule: Sampler_Declaration_States
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.Semicolon, TokenType.Comma, TokenType.CloseParenthesis); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.Semicolon:
                    tok = scanner.Scan(TokenType.Semicolon); // Terminal Rule: Semicolon
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Semicolon) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Semicolon.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.Comma:
                    tok = scanner.Scan(TokenType.Comma); // Terminal Rule: Comma
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.Comma) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.Comma.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.CloseParenthesis:
                    tok = scanner.Scan(TokenType.CloseParenthesis); // Terminal Rule: CloseParenthesis
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CloseParenthesis) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CloseParenthesis.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected Semicolon, Comma, or CloseParenthesis.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sampler_Declaration


    }

    #endregion Parser
}

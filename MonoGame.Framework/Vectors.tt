<# Write("// This code is generated by 'Vectors.tt'. Any modifications to its contents will be overwritten when the tool is next run. Modify 'Vectors.tt' directly instead."); #>

#region License
/*
Microsoft Public License (Ms-PL)
MonoGame - Copyright © 2009 The MonoGame Team

All rights reserved.

This license governs use of the accompanying software. If you use the software, you accept this license. If you do not
accept the license, do not use the software.

1. Definitions
The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here as under 
U.S. copyright law.

A "contribution" is the original software, or any additions or changes to the software.
A "contributor" is any person that distributes its contribution under this license.
"Licensed patents" are a contributor's patent claims that read directly on its contribution.

2. Grant of Rights
(A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, 
each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.
(B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, 
each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software.

3. Conditions and Limitations
(A) No Trademark License- This license does not grant you rights to use any contributors' name, logo, or trademarks.
(B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, 
your patent license from such contributor to the software ends automatically.
(C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution 
notices that are present in the software.
(D) If you distribute any portion of the software in source code form, you may do so only under this license by including 
a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object 
code form, you may only do so under a license that complies with this license.
(E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties, guarantees
or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent
permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular
purpose and non-infringement.
*/
#endregion License

// This file contains code that is "common" to the Vector2, Vector3, and Vector4 types, meaning that they can be simply expressed as either the exact same method or as a method with minor variations. Moving those methods from their static files to here makes documentation simpler, reduces error, and reduces code duplication.

// The downside is that the individual elements are harder to read and write for, BUT the extra issues do not surpass the benefits, particularly if we are clear and consistent.
// Only include a method if the variations are minor. For example, we could easily generate the rest of the constructors for Vector3 and Vector4, but those require conditionals. Keep that kind of thing out of here, as it's just too confusing.

// Inconsistencies and omissions that have been corrected:
// - Tests now confirms everything's operating properly.
// - Only Divide and Multiply operators were implemented against scalars; "vectors" have three different uses (as proper vectors, Cartesian coordinates, and general storage) so it's not appropriate to limit them like that.
// - Divide and Multiply static methods didn't handle scalars on the left.
// - Modulo operators weren't implemented.
// - Reflect was only in Vector2 and Vector3.
// - Unary + was missing as an operator.
// - Transform array with Matrix:
//   - Wasn't implemented in Vector4 and Vector3 had only the shortened signature. Very arbitrary!
//   - Didn't check its arguments, so it could write a bunch of stuff and then throw up.
//   - Didn't check for overlap, so it would produce incorrect results if the regions overlapped and source was before destination.
// - Transform array with Quaternion:
//   - Wasn't implemented in Vector2.
//   - Didn't check its arguments or for overlap.
// - Vector4 has "Vector4 Transform(Vector2, Matrix)" and "Vector4 Transform(Vector3, Matrix)" methods, but Vector3 lacked "Vector3 Transform(Vector2, Matrix)". This inconsistency has been amended.

<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

using System;
using System.Globalization;
using System.Runtime.Serialization;

namespace Microsoft.Xna.Framework
{
    <# /* Iterate over the three vector variants */ #>
    <# for(int order = 2; order <= 4; order++) { #>
        <# // Order-specific definitions.
            // "Vector2", "Vector3", or "Vector4", depending upon order.
            string Vn = "Vector" + order;

            // "two", "three", or "four", depending upon order.
            string Vv = VectorNumbers[order];

            // Self-referencing XML comment.
            string Vs = "<see cref=\"" + Vn + "\"/>";

            // The axes for this order. Iterating through them is useful for large operations. For smaller ones (like arguments to a method), use PerAxis, CommaAxis, AndPerAxis, and GenAxis below.
            List<AxisInfo> axes = new List<AxisInfo>(order);
            for(int axisIndex = 0; axisIndex < order; axisIndex++)
            {
                AxisInfo axis = Axes[axisIndex];
                axes.Add(axis);
                axis.IsLast = (axisIndex == order - 1);
            }
                
            // Write text that contains codes. The codes are:
            // "$" - "Vector#", where # is the order (same as Vn).
            // "#" - "two", "three", or "four", depending upon the order (same as Vv).
            Action<string> WriteCoded = (text) =>
            {
                if (text == null)
                    return;
                text = text.Replace("$", Vn);
                text = text.Replace("#", Vv);
            };

            // Write text that contains codes in addition to WriteCoded. The new codes are:
            // "@" - "X", "Y", "Z", or "W", depending upon axisIndex (same as AxisInfo.Id).
            // "`" - "x", "y", "z", or "w" (same as AxisInfo.SmallId).
            // "~" - "0", "1", "2", or "3" (same as AxisInfo.Index).
            // "_" - "1", "2", "3", or "4"
            Action<string, int> WriteAxisCoded = (text, axisIndex) =>
            {
                if(text == null) return;
                text = text.Replace('@', AxisIds[axisIndex]);
                text = text.Replace('`', AxisSmallIds[axisIndex]);
                text = text.Replace('~', (char)('0' + axisIndex));
                text = text.Replace('_', (char)('1' + axisIndex));
                Write(text);
            };

            // Expand the text (using WriteAxisCoded) for each axis, with the separator in between.
            // For example, PerAxis("@", ", ") writes "X, Y, Z" for order 3.
            Action<string, string> PerAxis = (text, separator) =>
            {
                for (int axisIndex = 0; axisIndex < order; axisIndex++)
                {
                    if (axisIndex > 0)
                        WriteAxisCoded(separator, axisIndex);
                    WriteAxisCoded(text, axisIndex);
                }
            };

            // Expand the text for each axis using a comma/newline/space to separate them. This is not to save space, but to make it faster to read.
            Action<string> CommaAxis = (text) => PerAxis(text, ", ");
            Action<string> NewlineAxis = (text) => PerAxis(text, Environment.NewLine);
            Action<string> SpaceAxis = (text) => PerAxis(text, " ");

            // As with PerAxis, but use a separate separator for the last component.
            Action<string, string, string> AndPerAxis = (text, separator, lastSeparator) =>
            {
                for(int axisIndex = 0; axisIndex < order; axisIndex++)
                {
                    if (axisIndex > 0)
                        WriteAxisCoded(axisIndex == order - 1 ? lastSeparator : separator, axisIndex);
                    WriteAxisCoded(text, axisIndex);
                }
            };

            // Call a delegate for each axis.
            Action<Func<AxisInfo, string>, string> GenAxis = (getText, separator) =>
            {
                for(int axisIndex = 0; axisIndex < order; axisIndex++)
                {
                    if(axisIndex > 0)
                        WriteAxisCoded(separator, axisIndex);
                    WriteAxisCoded(getText(Axes[axisIndex]), axisIndex);
                }
            };

            StaticMethodInfo[] VectorStaticMethods = new StaticMethodInfo[]
            {
                new StaticMethodInfo(false, Vn, Vn),
                new StaticMethodInfo(true, Vn, Vn)
            };

            StaticMethodInfo[] FloatStaticMethods = new StaticMethodInfo[]
            {
                new StaticMethodInfo(false, "float", Vn),
                new StaticMethodInfo(true, "float", Vn)
            };

        #>

        <# /* Now starts the per-order definition. */ #>

        /// <summary>A <#=Vv#>-dimensional floating-point <a href="http://en.wikipedia.org/wiki/Column_vector">column vector</a>.</summary>
        [DataContract]
        partial struct <#=Vn#> : IEquatable<<#=Vn#>>
        {
            #region Private fields

            // Implementation note: These constants cannot be "readonly" because they are passed by reference in the implementation.

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static <#=Vn#> zero = new <#=Vn#>(<#CommaAxis("0f");#>);

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static <#=Vn#> one = new <#=Vn#>(<#CommaAxis("1f");#>);

            <# foreach(var a in axes) { #>
                /// <summary>Backing field of the <see cref="Unit<#=a.Id#>"/> property.</summary>
                private static <#=Vn#> unit<#=a.Id#> = new <#=Vn#>(<#GenAxis((x) => x == a ? "1f" : "0f", ", ");#>);
            <# } #>

            #endregion Private fields

            #region Public fields

            <# foreach(var a in axes) { #>
                /// <summary>
                /// The <#=a.Ordinal#> axis of the <#=Vs#>.
                /// </summary>
                [DataMember]
                public float <#=a.Id#>;
            <# } #>

            #endregion Public fields

            #region Properties

            /// <summary>Get a <#=Vs#> where all of the components are zero.</summary>
            public static <#=Vn#> Zero { get { return zero; } }

            /// <summary>Get a <#=Vs#> where all of the components are one.</summary>
            public static <#=Vn#> One { get { return one; } }

            <# foreach(var a in axes) { #>
                /// <summary>Get a <#=Vs#> where the <#=a.Id#> component is one and the rest are zero.</summary>
                public static <#=Vn#> Unit<#=a.Id#> { get { return unit<#=a.Id#>; } }
            <# } #>

            #endregion Properties

            #region Constructors

            /// <summary>Initialize the components of the <#=Vs#>.</summary>
            <#NewlineAxis("/// <param name=\"`\">Value for the <see cref=\"@\"/> component.</param>");#>

            public <#=Vn#>(<#PerAxis("float `", ", ");#>)
            {
                <#NewlineAxis("@ = `;");#>
            }

            /// <summary>Initialize the components of the <#=Vn#> to the same value.</summary>
            /// <param name="value">The value to assign to the <#AndPerAxis("@", ", ", " and ");#> components.</param>
            public <#=Vn#>(float value)
            {
                <#SpaceAxis("@ =");#> value;
            }

            #endregion Constructors

            #region Public static methods

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>For each component of the <#=Vs#>s, compute the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate">Cartesian coordinate</a> for a point that is defined by a given triangle and two normalized <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)">barycentric (areal) coordinates</a>.</summary>
                /// <remarks>The effect of barycentric coordinates is that <paramref name="amount1"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value2"/> and <paramref name="amount2"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value3"/>, with zero for either amount being <paramref name="amount1"/> and one being the opposite corner. These coordinates are not linear.</remarks>
                /// <seealso cref="MathHelper.Barycentric"/>
                /// <param name="value1">The first vertex of the triangle. <#=s.RefNote#></param>
                /// <param name="value2">The second vertex of the triangle. <#=s.RefNote#></param>
                /// <param name="value3">The third vertex of the triangle. <#=s.RefNote#></param>
                /// <param name="amount1">The second barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value2"/>.</param>
                /// <param name="amount2">The third barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value3"/>.</param>
                /// <#=s.StartReturn#>The point at the given barycentric coordinates.<#=s.EndReturn#>
                <#=s.Declare("Barycentric(% value1, % value2, % value3, float amount1, float amount2)")#>
                    <# NewlineAxis("result.@ = MathHelper.Barycentric(value1.@, value2.@, value3.@, amount1, amount2);"); #>
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Catmull-Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which passes through <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/>, and <paramref name="value4"/> as <paramref name="amount"/> increases from 0 to 1.</summary>
                /// <seealso cref="MathHelper.CatmullRom"/>
                /// <param name="value1">The first <#=Vs#> along the spline. <#=s.RefNote#></param>
                /// <param name="value2">The second <#=Vs#> along the spline. <#=s.RefNote#></param>
                /// <param name="value3">The third <#=Vs#> along the spline. <#=s.RefNote#></param>
                /// <param name="value4">The fourth <#=Vs#> along the spline. <#=s.RefNote#></param>
                /// <param name="amount">The amount to interpolate along the spline, generally between 0 and 1.</param>
                /// <#=s.StartReturn#>The interpolated point.<#=s.EndReturn#>
                <#=s.Declare("CatmullRom(% value1, % value2, % value3, % value4, float amount)")#>
                    <# NewlineAxis("result.@ = MathHelper.CatmullRom(value1.@, value2.@, value3.@, value4.@, amount);"); #>
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Restrict the components of the <#=Vs#> to upper and lower boundaries.</summary>
                /// <param name="value1">The value to clamp. <#=s.RefNote#></param>
                /// <param name="min">The lower boundary. <#=s.RefNote#></param>
                /// <param name="max">The upper boundary. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The clamped value.<#=s.EndReturn#>
                <#=s.Declare("Clamp(% value1, % min, % max)")#>
                    <# NewlineAxis("result.@ = MathHelper.Clamp(value1.@, min.@, max.@);"); #>
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in FloatStaticMethods) { #>
                /// <summary>Compute the distance between the two <#=Vs#>.</summary>
                /// <param name="value1">The first <#=Vs#>. <#=s.RefNote#></param>
                /// <param name="value2">The second <#=Vs#>. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The distance between the two <#=Vs#> objects.<#=s.EndReturn#>
                <#=s.Declare("Distance(% value1, % value2)")#>
                    float <# CommaAxis("@ = value2.@ - value1.@"); #>;
                    result = (float)Math.Sqrt(<# PerAxis("@ * @", " + "); #>);
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in FloatStaticMethods) { #>
                /// <summary>Compute the squared distance between the two <#=Vs#>, which saves a square root over <see cref="Distance(<#=Vn#>,<#=Vn#>)"/></summary>
                /// <param name="value1">The first <#=Vs#>. <#=s.RefNote#></param>
                /// <param name="value2">The second <#=Vs#>. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The squared distance between the two <#=Vs#> values.<#=s.EndReturn#>
                <#=s.Declare("DistanceSquared(% value1, % value2)")#>
                    float <# CommaAxis("` = value2.@ - value1.@"); #>;
                    result = <# PerAxis("` * `", " + "); #>;
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in FloatStaticMethods) { #>
                /// <summary>Compute the <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> of the two <#=Vs#> values.</summary>
                /// <param name="value1">The first <#=Vs#>. <#=s.RefNote#></param>
                /// <param name="value2">The second <#=Vs#>. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The dot product of the parameters.<#=s.EndReturn#>
                <#=s.Declare("Dot(% value1, % value2)")#>
                    result = <# PerAxis("value1.@ * value2.@", " + "); #>;
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>.</summary>
                /// <param name="value1">The starting point.</param>
                /// <param name="tangent1">The tangent (the direction) of the spline at the start. <#=s.RefNote#></param>
                /// <param name="value2">The ending point. <#=s.RefNote#></param>
                /// <param name="tangent2">The tangent (the direction) of the spline at the end. <#=s.RefNote#></param>
                /// <param name="amount">The amount to interpolate on the curve between <paramref name="value1"/> (at <c>0.0f</c>) and <paramref name="value2"/> (at <c>1.0f</c>).</param>
                /// <#=s.StartReturn#>The interpolated value.<#=s.EndReturn#>
                <#=s.Declare("Hermite(% value1, % tangent1, % value2, % tangent2, float amount)")#>
                    <# NewlineAxis("result.@ = MathHelper.Hermite(value1.@, tangent1.@, value2.@, tangent2.@, amount);"); #>
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Linearly interpolate between the two <#=Vs#> values.</summary>
                /// <param name="value1">The starting <#=Vs#> value. <#=s.RefNote#></param>
                /// <param name="value2">The ending <#=Vs#> value. <#=s.RefNote#></param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <#=s.StartReturn#>The interpolated <#=Vs#> value.<#=s.EndReturn#>
                <#=s.Declare("Lerp(% value1, % value2, float amount)")#>
                    <# NewlineAxis("result.@ = MathHelper.Lerp(value1.@, value2.@, amount);"); #>
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Compute the maximum of each component of the <#=Vs#> values.</summary>
                /// <param name="value1">The first <#=Vs#>. <#=s.RefNote#></param>
                /// <param name="value2">The second <#=Vs#>. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>A <#=Vs#> containing the maximum of the <paramref name="value1"/> and <paramref name="value2"/> <#=Vs#>'s components.<#=s.EndReturn#>
                <#=s.Declare("Max(% value1, % value2)")#>
                    <# NewlineAxis("result.@ = Math.Max(value1.@, value2.@);"); #>
                <#=s.EndBody#>
            <# } #>


            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Compute the minimum of each component of the <#=Vs#> values.</summary>
                /// <param name="value1">The first <#=Vs#>. <#=s.RefNote#></param>
                /// <param name="value2">The second <#=Vs#>. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>A <#=Vs#> containing the minimum of the <paramref name="value1"/> and <paramref name="value2"/> <#=Vs#>'s components.<#=s.EndReturn#>
                <#=s.Declare("Min(% value1, % value2)")#>
                    <# NewlineAxis("result.@ = Math.Min(value1.@, value2.@);"); #>
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Compute the negative of each component of the <#=Vs#>.</summary>
                /// <param name="value">The <#=Vs#> to negate. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The negative <#=Vs#> value.<#=s.EndReturn#>
                <#=s.Declare("Negate(% value)")#>
                    <# NewlineAxis("result.@ = -value.@;"); #>
                <#=s.EndBody#>
            <# } #>

            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Divide a <#=Vs#> by its <see cref="Length"/>, resulting in a <#=Vs#> with a <see cref="Length"/> of one. If the <#=Vs#>'s original <see cref="Length"/> is one, then the result's components will all be <c>float.NaN</c>.</summary>
                /// <param name="value">The <#=Vs#> to normalize. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The normalized (or invalid) <#=Vs#> value.<#=s.EndReturn#>
                <#=s.Declare("Normalize(% value)")#>
                    float inverseLength = 1.0f / (float)Math.Sqrt(<# PerAxis("value.@ * value.@", " + "); #>);
                    <# NewlineAxis("result.@ = value.@ * inverseLength;"); #>
                <#=s.EndBody#>
            <# } #>

            <#/* Vn Reflect(Vn vector, Vn normal) */#>
            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Reflect a <#=Vs#> over a normal.</summary>
                /// <param name="vector">The <#=Vs#> to reflect. <#=s.RefNote#></param>
                /// <param name="normal">The normalized <#=Vs#> that is perpendicular to the surface to reflect off of.</param>
                /// <#=s.StartReturn#>The reflected <#=Vs#> value.<#=s.EndReturn#>
                <#=s.Declare("Reflect(% vector, % normal)")#>
                    // I is the original ray
                    // N is the normal of the incident plane
                    // R = I - (2 * N * DotProduct[I, N])
                    float dotProduct = <# PerAxis("vector.@ * normal.@", " + "); #>;

                    <# NewlineAxis("result.@ = vector.@ - (2.0f * normal.@) * dotProduct;"); #>
                <#=s.EndBody#>
            <# } #>

            <# /* Vn SmoothStep(Vn value1, Vn value2, float amount) */ #>
            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Interpolate using a <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> curve.</summary>
                /// <param name="value1">The start point. <#=s.RefNote#></param>
                /// <param name="value2">The end point. <#=s.RefNote#></param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <#=s.StartReturn#>The interpolated <#=Vs#> value.<#=s.EndReturn#>
                <#=s.Declare("SmoothStep(% value1, % value2, float amount)")#>
                    <# NewlineAxis("result.@ = MathHelper.SmoothStep(value1.@, value2.@, amount);"); #>
                <#=s.EndBody#>
            <# } #>

            <#/* Vn Transform(Vn position, Matrix matrix) */#>
            <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary>Transform the <see cref="Vector4"/> by the <see cref="Matrix"/>.</summary>
                /// <param name="position">The <see cref="Vector4"/> to transform. <#=s.RefNote#></param>
                /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The transformed <see cref="Vector4"/>.<#=s.EndReturn#>
                <#=s.Declare("Transform(% position, &Matrix matrix)")#>
                    result = new <#=Vn#>(
                        <# foreach(AxisInfo row in axes)
                        { #>
                            // Produce the "position.A * matrix.M## + ..." part.
                            <# foreach(AxisInfo column in axes) { #>
                                position.<#=column.Id#> * matrix.M<#=column.Index+1#><#=row.Index+1#><#=column.IsLast?"":" + "#>
                            <# } #>

                            // One-extend the W axis of vector types below order 4.
                            <# if(order < 4) { #>
                                + matrix.M4<#=row.Index+1#>
                            <# } #>
                    
                            <#=row.Comma#>
                        <# } #>);
                <#=s.EndBody#>
            <# } #>

            <#/* Vn Transform(Vector2 position, Matrix matrix) */#>
            <#if(order > 2)
            {#>
                <#foreach(StaticMethodInfo s in VectorStaticMethods) {#>
                    /// <summary>Transform a <see cref="Vector2"/> by a <see cref="Matrix"/>, extending the <see cref="Vector2"/> to produce a <see cref="Z"/> value of 0 and a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector2"/> to transform. <#=s.RefNote#></param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <#=Vs#>. <#=s.RefNote#></param>
                    /// <#=s.StartReturn#>The extended and transformed <#=Vs#>.<#=s.EndReturn#>
                    <#=s.Declare("Transform(&Vector2 position, &Matrix matrix)")#>
                        result = new <#=Vn#>(<#CommaAxis("position.X * matrix.M1_ + position.Y * matrix.M2_ + matrix.M4_");#>);
                    <#=s.EndBody#>
                <#}#>
            <#}#>

            <#/* Vector4 Transform(Vector3 position, Matrix matrix) */#>
            <#if(order > 3) {#>
                <#foreach(StaticMethodInfo s in VectorStaticMethods) {#>
                    /// <summary>Transform a <see cref="Vector3"/> by a <see cref="Matrix"/>, extending the <see cref="Vector3"/> to produce a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector3"/> to transform. <#=s.RefNote#></param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <#=Vs#>. <#=s.RefNote#></param>
                    /// <#=s.StartReturn#>The extended and transformed <#=Vs#>.<#=s.EndReturn#>
                    <#=s.Declare("Transform(&Vector3 position, &Matrix matrix)")#>
                        result = new <#=Vn#>(<#CommaAxis("position.X * matrix.M1_ + position.Y * matrix.M2_ + position.Z * matrix.M3_ + matrix.M4_");#>);
                    <#=s.EndBody#>
                <#}#>
            <#}#>

            <#/*Vn Transform(Vector[23] position, Quaternion rotation) */#>
            <#if(order < 4) {#>
                <#foreach(StaticMethodInfo s in VectorStaticMethods) {#>
                    /// <summary>Transforms a <#=Vs#> by a <see cref="Quaternion"/> rotation.</summary>
                    /// <param name="vector">The <#=Vs#> to transform. <#=s.RefNote#></param>
                    /// <param name="rotation">The <see cref="Quaternion"/> to rotate the <#=Vs#> by. <#=s.RefNote#></param>
                    /// <#=s.StartReturn#>The result of the transformation.<#=s.EndReturn#>
                    <#=s.Declare("Transform(% vector, &Quaternion rotation)")#>
                        float vz = <#=order > 2 ? "vector.Z" : "0f"#>;
                        float x = 2 * (rotation.Y * vz - rotation.Z * vector.Y);
                        float y = 2 * (rotation.Z * vector.X - rotation.X * vz);
                        float z = 2 * (rotation.X * vector.Y - rotation.Y * vector.X);

                        result.X = vector.X + x * rotation.W + (rotation.Y * z - rotation.Z * y);
                        result.Y = vector.Y + y * rotation.W + (rotation.Z * x - rotation.X * z);
                        <#if(order > 2) {#>
                            result.Z = vector.Z + z * rotation.W + (rotation.X * y - rotation.Y * x);
                        <#}#>
                    <#=s.EndBody#>
                <#}#>
            <#}#>

            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <#=Vs#> values. The arrays may be the same.</summary>
            /// <param name="sourceArray">The array of <#=Vs#> values to transform.</param>
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <#=Vs#> values by.</param>
            /// <param name="destinationArray">The array to store transformed <#=Vs#> values in.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="sourceArray"/>'s <see cref="Array.Length"/> is greater than <paramref name="destinationArray"/>'s <see cref="Array.Length"/></exception>
            public static void Transform(<#=Vn#>[] sourceArray, ref Matrix matrix, <#=Vn#>[] destinationArray)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                Transform(sourceArray, 0, ref matrix, destinationArray, 0, sourceArray.Length);
            }

            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <#=Vs#> values. The arrays may be the same and the regions may overlap.</summary>
            /// <param name="sourceArray">The array of <#=Vs#> values to transform.</param>
            /// <param name="sourceIndex">The index of the first element of <paramref name="sourceArray"/> to transform.</param> 
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <#=Vs#> values by.</param>
            /// <param name="destinationArray">The array to store transformed <#=Vs#> values in.</param>
            /// <param name="destinationIndex">The index of the first element of <paramref name="destinationArray"/> to write to.</param>
            /// <param name="length">The number of <#=Vs#> values to transform.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/>, <paramref name="sourceIndex"/>, or <paramref name="destinationIndex"/> are below zero; or else the range given by <c><paramref name="sourceIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="sourceArray"/>; or else the range given by <c><paramref name="destinationIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="destinationArray"/>.</exception>
            public static void Transform(
                <#=Vn#>[] sourceArray,
                int sourceIndex,
                ref Matrix matrix,
                <#=Vn#>[] destinationArray,
                int destinationIndex,
                int length)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                if (destinationArray == null)
                    throw new ArgumentNullException("destinationArray");
                if (length < 0)
                    throw new ArgumentOutOfRangeException("length");
                if (sourceIndex < 0 || sourceIndex + length > sourceArray.Length)
                    throw new ArgumentOutOfRangeException("sourceIndex");
                if (destinationIndex < 0 || destinationIndex + length > destinationArray.Length)
                    throw new ArgumentOutOfRangeException("destinationIndex");

                // See whether we might need to iterate backwards.
                if (object.ReferenceEquals(sourceArray, destinationArray) && sourceIndex < destinationIndex)
                {
                    // We might need to iterate backwards, or else we'll overwrite source vertices before they're transformed.
                    // This is a "might" because we don't check for overlap, we just play it safe.
                    for (int index = length - 1; index >= 0; index--)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
                else
                {
                    for (int index = 0; index < length; index++)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
            }

            <#if(order < 4) {#>
                /// <summary>Apply a <see cref="Quaternion"/> transform to an array of <#=Vs#> values. The arrays may be the same.</summary>
                /// <param name="sourceArray">The array of <#=Vs#> values to transform.</param>
                /// <param name="rotation">The <see cref="Quaternion"/> to transform the <#=Vs#> values by.</param>
                /// <param name="destinationArray">The array to store transformed <#=Vs#> values in.</param>
                /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
                /// <exception cref="ArgumentOutOfRangeException"><paramref name="sourceArray"/>'s <see cref="Array.Length"/> is greater than <paramref name="destinationArray"/>'s <see cref="Array.Length"/></exception>
                public static void Transform(<#=Vn#>[] sourceArray, ref Quaternion rotation, <#=Vn#>[] destinationArray)
                {
                    if (sourceArray == null)
                        throw new ArgumentNullException("sourceArray");
                    Transform(sourceArray, 0, ref rotation, destinationArray, 0, sourceArray.Length);
                }

                /// <summary>Apply a <see cref="Quaternion"/> transform to an array of <#=Vs#> values. The arrays may be the same and the regions may overlap.</summary>
                /// <param name="sourceArray">The array of <#=Vs#> values to transform.</param>
                /// <param name="sourceIndex">The index of the first element of <paramref name="sourceArray"/> to transform.</param> 
                /// <param name="rotation">The <see cref="Quaternion"/> to transform the <#=Vs#> values by.</param>
                /// <param name="destinationArray">The array to store transformed <#=Vs#> values in.</param>
                /// <param name="destinationIndex">The index of the first element of <paramref name="destinationArray"/> to write to.</param>
                /// <param name="length">The number of <#=Vs#> values to transform.</param>
                /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
                /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/>, <paramref name="sourceIndex"/>, or <paramref name="destinationIndex"/> are below zero; or else the range given by <c><paramref name="sourceIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="sourceArray"/>; or else the range given by <c><paramref name="destinationIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="destinationArray"/>.</exception>
                public static void Transform(
                    <#=Vn#>[] sourceArray,
                    int sourceIndex,
                    ref Quaternion rotation,
                    <#=Vn#>[] destinationArray,
                    int destinationIndex,
                    int length)
                {
                    if (sourceArray == null)
                        throw new ArgumentNullException("sourceArray");
                    if (destinationArray == null)
                        throw new ArgumentNullException("destinationArray");
                    if (length < 0)
                        throw new ArgumentOutOfRangeException("length");
                    if (sourceIndex < 0 || sourceIndex + length > sourceArray.Length)
                        throw new ArgumentOutOfRangeException("sourceIndex");
                    if (destinationIndex < 0 || destinationIndex + length > destinationArray.Length)
                        throw new ArgumentOutOfRangeException("destinationIndex");

                    // See whether we might need to iterate backwards.
                    if (object.ReferenceEquals(sourceArray, destinationArray) && sourceIndex < destinationIndex)
                    {
                        // We might need to iterate backwards, or else we'll overwrite source vertices before they're transformed.
                        // This is a "might" because we don't check for overlap, we just play it safe.
                        for (int index = length - 1; index >= 0; index--)
                            Transform(ref sourceArray[sourceIndex + index], ref rotation, out destinationArray[destinationIndex + index]);
                    }
                    else
                    {
                        for (int index = 0; index < length; index++)
                            Transform(ref sourceArray[sourceIndex + index], ref rotation, out destinationArray[destinationIndex + index]);
                    }
                }
            <#}#>

            <#/* Vn TransformNormal(Vn normal, Matrix matrix) */#>
            <#if(order < 4) {#>
                <#foreach(StaticMethodInfo s in VectorStaticMethods) {#>
                    /// <summary>Transform the <#=Vs#> by a <see cref="Matrix"/>, ignoring the translation component of the <see cref="Matrix"/>. The input and the results are not normalized.</summary>
                    /// <param name="position">The <#=Vs#> to transform. <#=s.RefNote#></param>
                    /// <param name="matrix">The transformation <see cref="Matrix"/>. <#=s.RefNote#></param>
                    /// <#=s.StartReturn#>The transformed <#=Vs#> normal.<#=s.EndReturn#>
                    <#=s.Declare("TransformNormal(% position, &Matrix matrix)")#>
                        result = new <#=Vn#>(<#foreach(AxisInfo row in axes) {#>
                            // Produce the "position.A * matrix.M## + ..." part.
                            <#foreach(AxisInfo column in axes) {#>
                                position.<#=column.Id#> * matrix.M<#=column.Index+1#><#=row.Index+1#><#=column.IsLast?"":" + "#>
                            <#}#>
                    
                            <#=row.Comma#>
                        <#}#>);
                    <#=s.EndBody#>
                <#}#>
            <#}#>

            #endregion Public static methods

            #region Public methods

            /// <summary>Determine whether this <#=Vs#> and the other are equivalent, which is only possible if <paramref name="obj"/> is a <#=Vs#> with equivalent axes.</summary>
            /// <param name="obj">The object to compare to.</param>
            /// <returns>Whether the objects are equivalent.</returns>
            public override bool Equals(object obj)
            {
			    if(obj is <#=Vn#>)
			    {
                    <#=Vn#> other = (<#=Vn#>)obj;
                    return <# PerAxis("@ == other.@", " && "); #>;
			    }
			
                return false;
            }

            /// <summary>Determine whether this <#=Vs#> and the other <#=Vs#> are equivalent in all components.</summary>
            /// <param name="other">The <#=Vs#> to compare to.</param>
            /// <returns>Whether the <#=Vs#> values are equivalent.</returns>
            public bool Equals(<#=Vn#> other)
            {
                return <# PerAxis("@ == other.@", " && "); #>;
            }

            /// <summary>Get a hash code value that is as different from other, similiar <#=Vs#> as possible.</summary>
            /// <returns>The hash code value.</returns>
            public override int GetHashCode()
            {
                return <# PerAxis("@.GetHashCode() * 31", " ^ "); #>;
            }

            /// <summary>Compute the length of the <#=Vs#>, which is the distance from the origin.</summary>
            /// <returns>The length of the <#=Vs#>.</returns>
            public float Length()
            {
                return (float)Math.Sqrt(<# PerAxis("@ * @", " + "); #>);
            }

            /// <summary>Compute the squared length of the <#=Vs#>, which is the squared distance from the origin. The squared length avoids a square root over <see cref="Length"/>, which is therefore faster.</summary>
            /// <returns>The squared length of the <#=Vs#>.</returns>
            public float LengthSquared()
            {
                return <# PerAxis("@ * @", " + "); #>;
            }

            /// <summary>Divide the <#=Vs#> by its <see cref="Length"/> so that its <see cref="Length"/> is one. If its original length is 0, then all components will be set to <c>float.NaN</c>.</summary>
            public void Normalize()
            {
                float inverseLength = 1.0f / (float)Math.Sqrt(<# PerAxis("@ * @", " + "); #>);
                <# NewlineAxis("@ *= inverseLength;"); #>
            }

            /// <summary>Convert to a string of the form "{<# PerAxis("@:`", " "); #>}".</summary>
            /// <returns>The string representation of this <#=Vs#>.</returns>
            public override string ToString()
            {
                CultureInfo currentCulture = CultureInfo.CurrentCulture;
                return string.Format(currentCulture, "{{<# PerAxis("@:{~}", " "); #>}}", new object[] { <# CommaAxis("@.ToString(currentCulture)"); #> });
            }

            #endregion Public methods

            #region Operators and operator methods

            /// <summary>Compute the negative of the value (which is the value).</summary>
            /// <param name="value">The <#=Vs#>.</param>
            /// <returns>The <#=Vs#>.</returns>
            public static <#=Vn#> operator +(<#=Vn#> value)
            {
                <# NewlineAxis("value.@ = +value.@;"); #>
                return value;
            }

            /// <summary>Compute the negative of the value.</summary>
            /// <param name="value">The <#=Vs#> to negate.</param>
            /// <returns>The negated <#=Vs#>.</returns>
            public static <#=Vn#> operator -(<#=Vn#> value)
            {
                <# NewlineAxis("value.@ = -value.@;"); #>
                return value;
            }

            /// <summary>Compute whether the two <#=Vs#> values are equal.</summary>
            /// <param name="value1">The first <#=Vs#> to compare.</param>
            /// <param name="value2">The second <#=Vs#> to compare.</param>
            /// <returns>Whether the <#=Vs#> values are equal.</returns>
            public static bool operator ==(<#=Vn#> value1, <#=Vn#> value2)
            {
                return <# PerAxis("value1.@ == value2.@", "&&"); #>;
            }

            /// <summary>Compute whether the two <#=Vs#> values are not equal.</summary>
            /// <param name="value1">The first <#=Vs#> to compare.</param>
            /// <param name="value2">The second <#=Vs#> to compare.</param>
            /// <returns>Whether the <#=Vs#> values are not equal.</returns>
            public static bool operator !=(<#=Vn#> value1, <#=Vn#> value2)
            {
                return <# PerAxis("value1.@ != value2.@", "||"); #>;
            }

            <# foreach(OperatorInfo o in Operators) { #>
                // Vn Operator(Vn value1, Vn value2)
                <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary><#=o.Name#> the components of the <#=Vs#>s.</summary>
                /// <param name="value1">The left side of the equation. <#=s.RefNote#></param>
                /// <param name="value2">The right side of the equation. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The result of the operation.<#=s.EndReturn#>
                <#=s.Declare(o.Name + "(% value1, % value2)")#>
                    <# NewlineAxis("result.@ = value1.@ " + o.Operator + " value2.@;"); #>
                <#=s.EndBody#>
                <# } #>

                <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary><#=o.Name#>The components of a <#=Vs#> with a scalar.</summary>
                /// <param name="value1">The <#=Vs#> left side of the equation. <#=s.RefNote#></param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <#=s.StartReturn#>The result of the operation.<#=s.EndReturn#>
                <#=s.Declare(o.Name + "(% value1, float value2)")#>
                    <# NewlineAxis("result.@ = value1.@ " + o.Operator + " value2;"); #>
                <#=s.EndBody#>
                <# } #>

                <# foreach(StaticMethodInfo s in VectorStaticMethods) { #>
                /// <summary><#=o.Name#>The components of a <#=Vs#> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <#=Vs#> right side of the equation. <#=s.RefNote#></param>
                /// <#=s.StartReturn#>The result of the operation.<#=s.EndReturn#>
                <#=s.Declare(o.Name + "(float value1, % value2)")#>
                    <# NewlineAxis("result.@ = value1 " + o.Operator + " value2.@;"); #>
                <#=s.EndBody#>
                <# } #>

                /// <summary><#=o.Name#> the components of the <#=Vs#>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static <#=Vn#> operator <#=o.Operator#>(<#=Vn#> value1, <#=Vn#> value2)
                {
                    <# NewlineAxis("value1.@ " + o.Operator + "= value2.@;"); #>
                    return value1;
                }

                /// <summary><#=o.Name#> the components of a <#=Vs#> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static <#=Vn#> operator <#=o.Operator#>(<#=Vn#> value1, float value2)
                {
                    <# NewlineAxis("value1.@ " + o.Operator + "= value2;"); #>
                    return value1;
                }

                /// <summary><#=o.Name#> the components of a <#=Vs#> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static <#=Vn#> operator <#=o.Operator#>(float value1, <#=Vn#> value2)
                {
                    <# NewlineAxis("value2.@ = value1 " + o.Operator + " value2.@;"); #>
                    return value2;
                }
            <# } #>

            #endregion Operators and operator methods
        }

        <# /* Now ends the per-order vector definition. */ #>
    <# } #>
}


<#+ // Class features

    // Zero-based axis identifier names.
    char[] AxisIds = new char[] { 'X', 'Y', 'Z', 'W' };
    char[] AxisSmallIds = new char[] { 'x', 'y', 'z', 'w' };
    string[] AxisOrdinals = new string[] { "first", "second", "third", "fourth" };

    // Vector type names indexed by number of axes.
    string[] VectorNames = new string[] { null, null, "Vector2", "Vector3", "Vector4" };
    string[] VectorNumbers = new string[] { null, null, "two", "three", "four" };

    public class AxisInfo
    {
        /// <summary>The zero-based index of the axis.</summary>
        public int Index;

        /// <summary>The single-character id of the axis, like "X", "Y", "Z", and "W".</summary>
        public string Id;

        /// <summary>The single-character id of the axis in lower case, like "x", "y", "z", and "w".</summary>
        public string SmallId;

        /// <summary>The ordinal name of the axis, as in "first", "second", "third", and "fourth".</summary>
        public string Ordinal;

        /// <summary>This is assigned when iterating to indicate the last axis.</summary>
        public bool IsLast;

        /// <summary>Return "" or ", " depending upon whether this is the last axis of this vector type.</summary>
        public string Comma { get { return IsLast ? "" : ", "; } }
    }

    public static readonly AxisInfo[] Axes = new AxisInfo[]
    {
        new AxisInfo() { Index = 0, Id = "X", SmallId = "x", Ordinal = "first" },
        new AxisInfo() { Index = 1, Id = "Y", SmallId = "y", Ordinal = "second" },
        new AxisInfo() { Index = 2, Id = "Z", SmallId = "z", Ordinal = "third" },
        new AxisInfo() { Index = 3, Id = "W", SmallId = "w", Ordinal = "fourth" },
    };

    public class OperatorInfo
    {
        /// <summary>Capitalized name of the operator, such as "Add"</summary>
        public string Name;

        /// <summary>The C# operator itself, such as "+".</summary>
        public string Operator;

        /// <summary>Whether the operator can handle facing up against scalars.</summary>
        public bool UseScalars;
    }

    public static readonly OperatorInfo[] Operators = new OperatorInfo[]
    {
        new OperatorInfo() { Name = "Add", Operator = "+" },
        new OperatorInfo() { Name = "Subtract", Operator = "-" },
        new OperatorInfo() { Name = "Multiply", Operator = "*" },
        new OperatorInfo() { Name = "Divide", Operator = "/" },
        new OperatorInfo() { Name = "Modulo", Operator = "%" },
    };

    public class StaticMethodInfo
    {
        public StaticMethodInfo(bool passByRef, string typeName, string vectorType)
        {
            this.VectorType = vectorType;
            if(passByRef)
            {
                StartReturn = "<param name=\"result\">";
                EndReturn = " The parameter may point to any member of the other parameters without affecting the result.</param>";
                Ref = "ref ";
                RefNote = "The contents will not be modified; pass by reference is only for optimization.";
                Out = ", out " + typeName + " result";
            }
            else
            {
                Return = "public static " + typeName;
                StartBody = "{ " + typeName + " result;";
                EndBody = "return result; }";
            }
        }

        public string VectorType;

        // Either "<returns>" or "<param name="result">".
        public string StartReturn = "<returns>";

        // Either "</returns>" or "</param>".
        public string EndReturn = "</returns>";

        // Either "" or "ref"
        public string Ref = "";

        // Either "" or "The contents will not be modified
        public string RefNote = "";

        // Either "float/Vn" or "void".
        public string Return = "public static void";

        // Either "" or ", out float/Vn result".
        public string Out = "";

        // Either "{ float/Vn result;" or "{".
        public string StartBody = "{";

        // Either "return result; }" or "}"
        public string EndBody = "}";

        public string Declare(string text)
        {
            return Return + " " + text.Replace("%", Ref + VectorType).Replace("&", Ref).Replace(")", Out + ")" + StartBody);
        }
    }
#>
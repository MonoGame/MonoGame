// This code is generated by 'Vectors.tt'. Any modifications to its contents will be overwritten when the tool is next run. Modify 'Vectors.tt' directly instead.
#region License
/*
Microsoft Public License (Ms-PL)
MonoGame - Copyright © 2009 The MonoGame Team

All rights reserved.

This license governs use of the accompanying software. If you use the software, you accept this license. If you do not
accept the license, do not use the software.

1. Definitions
The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here as under 
U.S. copyright law.

A "contribution" is the original software, or any additions or changes to the software.
A "contributor" is any person that distributes its contribution under this license.
"Licensed patents" are a contributor's patent claims that read directly on its contribution.

2. Grant of Rights
(A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, 
each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.
(B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, 
each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software.

3. Conditions and Limitations
(A) No Trademark License- This license does not grant you rights to use any contributors' name, logo, or trademarks.
(B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, 
your patent license from such contributor to the software ends automatically.
(C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution 
notices that are present in the software.
(D) If you distribute any portion of the software in source code form, you may do so only under this license by including 
a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object 
code form, you may only do so under a license that complies with this license.
(E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties, guarantees
or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent
permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular
purpose and non-infringement.
*/
#endregion License

// This file contains code that is "common" to the Vector2, Vector3, and Vector4 types, meaning that they can be simply expressed as either the exact same method or as a method with minor variations. Moving those methods from their static files to here makes documentation simpler, reduces error, and reduces code duplication.

// The downside is that the individual elements are harder to read and write for, BUT the extra issues do not surpass the benefits, particularly if we are clear and consistent.
// Only include a method if the variations are minor. For example, we could easily generate the rest of the constructors for Vector3 and Vector4, but those require conditionals. Keep that kind of thing out of here, as it's just too confusing.

// Inconsistencies and omissions that have been corrected:
// - Tests now confirms everything's operating properly.
// - Only Divide and Multiply operators were implemented against scalars; "vectors" have three different uses (as proper vectors, Cartesian coordinates, and general storage) so it's not appropriate to limit them like that.
// - Divide and Multiply static methods didn't handle scalars on the left.
// - Modulo operators weren't implemented.
// - Reflect was only in Vector2 and Vector3.
// - Unary + was missing as an operator.
// - Transform array with Matrix:
//   - Wasn't implemented in Vector4 and Vector3 had only the shortened signature. Very arbitrary!
//   - Didn't check its arguments, so it could write a bunch of stuff and then throw up.
//   - Didn't check for overlap, so it would produce incorrect results if the regions overlapped and source was before destination.
// - Transform array with Quaternion:
//   - Wasn't implemented in Vector2.
//   - Didn't check its arguments or for overlap.
// - Vector4 has "Vector4 Transform(Vector2, Matrix)" and "Vector4 Transform(Vector3, Matrix)" methods, but Vector3 lacked "Vector3 Transform(Vector2, Matrix)". This inconsistency has been amended.


using System;
using System.Globalization;
using System.Runtime.Serialization;

namespace Microsoft.Xna.Framework
{
                
        
        /// <summary>A two-dimensional floating-point <a href="http://en.wikipedia.org/wiki/Column_vector">column vector</a>.</summary>
        [DataContract]
        partial struct Vector2 : IEquatable<Vector2>
        {
            #region Private fields

            // Implementation note: These constants cannot be "readonly" because they are passed by reference in the implementation.

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static Vector2 zero = new Vector2(0f, 0f);

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static Vector2 one = new Vector2(1f, 1f);

                            /// <summary>Backing field of the <see cref="UnitX"/> property.</summary>
                private static Vector2 unitX = new Vector2(1f, 0f);
                            /// <summary>Backing field of the <see cref="UnitY"/> property.</summary>
                private static Vector2 unitY = new Vector2(0f, 1f);
            
            #endregion Private fields

            #region Public fields

                            /// <summary>
                /// The first axis of the <see cref="Vector2"/>.
                /// </summary>
                [DataMember]
                public float X;
                            /// <summary>
                /// The second axis of the <see cref="Vector2"/>.
                /// </summary>
                [DataMember]
                public float Y;
            
            #endregion Public fields

            #region Properties

            /// <summary>Get a <see cref="Vector2"/> where all of the components are zero.</summary>
            public static Vector2 Zero { get { return zero; } }

            /// <summary>Get a <see cref="Vector2"/> where all of the components are one.</summary>
            public static Vector2 One { get { return one; } }

                            /// <summary>Get a <see cref="Vector2"/> where the X component is one and the rest are zero.</summary>
                public static Vector2 UnitX { get { return unitX; } }
                            /// <summary>Get a <see cref="Vector2"/> where the Y component is one and the rest are zero.</summary>
                public static Vector2 UnitY { get { return unitY; } }
            
            #endregion Properties

            #region Constructors

            /// <summary>Initialize the components of the <see cref="Vector2"/>.</summary>
            /// <param name="x">Value for the <see cref="X"/> component.</param>
/// <param name="y">Value for the <see cref="Y"/> component.</param>
            public Vector2(float x, float y)
            {
                X = x;
Y = y;            }

            /// <summary>Initialize the components of the Vector2 to the same value.</summary>
            /// <param name="value">The value to assign to the X and Y components.</param>
            public Vector2(float value)
            {
                X = Y = value;
            }

            #endregion Constructors

            #region Public static methods

                            /// <summary>For each component of the <see cref="Vector2"/>s, compute the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate">Cartesian coordinate</a> for a point that is defined by a given triangle and two normalized <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)">barycentric (areal) coordinates</a>.</summary>
                /// <remarks>The effect of barycentric coordinates is that <paramref name="amount1"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value2"/> and <paramref name="amount2"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value3"/>, with zero for either amount being <paramref name="amount1"/> and one being the opposite corner. These coordinates are not linear.</remarks>
                /// <seealso cref="MathHelper.Barycentric"/>
                /// <param name="value1">The first vertex of the triangle. </param>
                /// <param name="value2">The second vertex of the triangle. </param>
                /// <param name="value3">The third vertex of the triangle. </param>
                /// <param name="amount1">The second barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value2"/>.</param>
                /// <param name="amount2">The third barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value3"/>.</param>
                /// <returns>The point at the given barycentric coordinates.</returns>
                public static Vector2 Barycentric(Vector2 value1, Vector2 value2, Vector2 value3, float amount1, float amount2){ Vector2 result;
                    result.X = MathHelper.Barycentric(value1.X, value2.X, value3.X, amount1, amount2);
result.Y = MathHelper.Barycentric(value1.Y, value2.Y, value3.Y, amount1, amount2);                return result; }
                            /// <summary>For each component of the <see cref="Vector2"/>s, compute the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate">Cartesian coordinate</a> for a point that is defined by a given triangle and two normalized <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)">barycentric (areal) coordinates</a>.</summary>
                /// <remarks>The effect of barycentric coordinates is that <paramref name="amount1"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value2"/> and <paramref name="amount2"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value3"/>, with zero for either amount being <paramref name="amount1"/> and one being the opposite corner. These coordinates are not linear.</remarks>
                /// <seealso cref="MathHelper.Barycentric"/>
                /// <param name="value1">The first vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value3">The third vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount1">The second barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value2"/>.</param>
                /// <param name="amount2">The third barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value3"/>.</param>
                /// <param name="result">The point at the given barycentric coordinates. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Barycentric(ref Vector2 value1, ref Vector2 value2, ref Vector2 value3, float amount1, float amount2, out Vector2 result){
                    result.X = MathHelper.Barycentric(value1.X, value2.X, value3.X, amount1, amount2);
result.Y = MathHelper.Barycentric(value1.Y, value2.Y, value3.Y, amount1, amount2);                }
            
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Catmull-Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which passes through <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/>, and <paramref name="value4"/> as <paramref name="amount"/> increases from 0 to 1.</summary>
                /// <seealso cref="MathHelper.CatmullRom"/>
                /// <param name="value1">The first <see cref="Vector2"/> along the spline. </param>
                /// <param name="value2">The second <see cref="Vector2"/> along the spline. </param>
                /// <param name="value3">The third <see cref="Vector2"/> along the spline. </param>
                /// <param name="value4">The fourth <see cref="Vector2"/> along the spline. </param>
                /// <param name="amount">The amount to interpolate along the spline, generally between 0 and 1.</param>
                /// <returns>The interpolated point.</returns>
                public static Vector2 CatmullRom(Vector2 value1, Vector2 value2, Vector2 value3, Vector2 value4, float amount){ Vector2 result;
                    result.X = MathHelper.CatmullRom(value1.X, value2.X, value3.X, value4.X, amount);
result.Y = MathHelper.CatmullRom(value1.Y, value2.Y, value3.Y, value4.Y, amount);                return result; }
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Catmull-Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which passes through <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/>, and <paramref name="value4"/> as <paramref name="amount"/> increases from 0 to 1.</summary>
                /// <seealso cref="MathHelper.CatmullRom"/>
                /// <param name="value1">The first <see cref="Vector2"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector2"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value3">The third <see cref="Vector2"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value4">The fourth <see cref="Vector2"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate along the spline, generally between 0 and 1.</param>
                /// <param name="result">The interpolated point. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void CatmullRom(ref Vector2 value1, ref Vector2 value2, ref Vector2 value3, ref Vector2 value4, float amount, out Vector2 result){
                    result.X = MathHelper.CatmullRom(value1.X, value2.X, value3.X, value4.X, amount);
result.Y = MathHelper.CatmullRom(value1.Y, value2.Y, value3.Y, value4.Y, amount);                }
            
                            /// <summary>Restrict the components of the <see cref="Vector2"/> to upper and lower boundaries.</summary>
                /// <param name="value1">The value to clamp. </param>
                /// <param name="min">The lower boundary. </param>
                /// <param name="max">The upper boundary. </param>
                /// <returns>The clamped value.</returns>
                public static Vector2 Clamp(Vector2 value1, Vector2 min, Vector2 max){ Vector2 result;
                    result.X = MathHelper.Clamp(value1.X, min.X, max.X);
result.Y = MathHelper.Clamp(value1.Y, min.Y, max.Y);                return result; }
                            /// <summary>Restrict the components of the <see cref="Vector2"/> to upper and lower boundaries.</summary>
                /// <param name="value1">The value to clamp. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="min">The lower boundary. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="max">The upper boundary. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The clamped value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Clamp(ref Vector2 value1, ref Vector2 min, ref Vector2 max, out Vector2 result){
                    result.X = MathHelper.Clamp(value1.X, min.X, max.X);
result.Y = MathHelper.Clamp(value1.Y, min.Y, max.Y);                }
            
                            /// <summary>Compute the distance between the two <see cref="Vector2"/>.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. </param>
                /// <param name="value2">The second <see cref="Vector2"/>. </param>
                /// <returns>The distance between the two <see cref="Vector2"/> objects.</returns>
                public static float Distance(Vector2 value1, Vector2 value2){ float result;
                    float X = value2.X - value1.X, Y = value2.Y - value1.Y;
                    result = (float)Math.Sqrt(X * X + Y * Y);
                return result; }
                            /// <summary>Compute the distance between the two <see cref="Vector2"/>.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The distance between the two <see cref="Vector2"/> objects. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Distance(ref Vector2 value1, ref Vector2 value2, out float result){
                    float X = value2.X - value1.X, Y = value2.Y - value1.Y;
                    result = (float)Math.Sqrt(X * X + Y * Y);
                }
            
                            /// <summary>Compute the squared distance between the two <see cref="Vector2"/>, which saves a square root over <see cref="Distance(Vector2,Vector2)"/></summary>
                /// <param name="value1">The first <see cref="Vector2"/>. </param>
                /// <param name="value2">The second <see cref="Vector2"/>. </param>
                /// <returns>The squared distance between the two <see cref="Vector2"/> values.</returns>
                public static float DistanceSquared(Vector2 value1, Vector2 value2){ float result;
                    float x = value2.X - value1.X, y = value2.Y - value1.Y;
                    result = x * x + y * y;
                return result; }
                            /// <summary>Compute the squared distance between the two <see cref="Vector2"/>, which saves a square root over <see cref="Distance(Vector2,Vector2)"/></summary>
                /// <param name="value1">The first <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The squared distance between the two <see cref="Vector2"/> values. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void DistanceSquared(ref Vector2 value1, ref Vector2 value2, out float result){
                    float x = value2.X - value1.X, y = value2.Y - value1.Y;
                    result = x * x + y * y;
                }
            
                            /// <summary>Compute the <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> of the two <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. </param>
                /// <param name="value2">The second <see cref="Vector2"/>. </param>
                /// <returns>The dot product of the parameters.</returns>
                public static float Dot(Vector2 value1, Vector2 value2){ float result;
                    result = value1.X * value2.X + value1.Y * value2.Y;
                return result; }
                            /// <summary>Compute the <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> of the two <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The dot product of the parameters. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Dot(ref Vector2 value1, ref Vector2 value2, out float result){
                    result = value1.X * value2.X + value1.Y * value2.Y;
                }
            
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>.</summary>
                /// <param name="value1">The starting point.</param>
                /// <param name="tangent1">The tangent (the direction) of the spline at the start. </param>
                /// <param name="value2">The ending point. </param>
                /// <param name="tangent2">The tangent (the direction) of the spline at the end. </param>
                /// <param name="amount">The amount to interpolate on the curve between <paramref name="value1"/> (at <c>0.0f</c>) and <paramref name="value2"/> (at <c>1.0f</c>).</param>
                /// <returns>The interpolated value.</returns>
                public static Vector2 Hermite(Vector2 value1, Vector2 tangent1, Vector2 value2, Vector2 tangent2, float amount){ Vector2 result;
                    result.X = MathHelper.Hermite(value1.X, tangent1.X, value2.X, tangent2.X, amount);
result.Y = MathHelper.Hermite(value1.Y, tangent1.Y, value2.Y, tangent2.Y, amount);                return result; }
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>.</summary>
                /// <param name="value1">The starting point.</param>
                /// <param name="tangent1">The tangent (the direction) of the spline at the start. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The ending point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="tangent2">The tangent (the direction) of the spline at the end. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate on the curve between <paramref name="value1"/> (at <c>0.0f</c>) and <paramref name="value2"/> (at <c>1.0f</c>).</param>
                /// <param name="result">The interpolated value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Hermite(ref Vector2 value1, ref Vector2 tangent1, ref Vector2 value2, ref Vector2 tangent2, float amount, out Vector2 result){
                    result.X = MathHelper.Hermite(value1.X, tangent1.X, value2.X, tangent2.X, amount);
result.Y = MathHelper.Hermite(value1.Y, tangent1.Y, value2.Y, tangent2.Y, amount);                }
            
                            /// <summary>Linearly interpolate between the two <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The starting <see cref="Vector2"/> value. </param>
                /// <param name="value2">The ending <see cref="Vector2"/> value. </param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <returns>The interpolated <see cref="Vector2"/> value.</returns>
                public static Vector2 Lerp(Vector2 value1, Vector2 value2, float amount){ Vector2 result;
                    result.X = MathHelper.Lerp(value1.X, value2.X, amount);
result.Y = MathHelper.Lerp(value1.Y, value2.Y, amount);                return result; }
                            /// <summary>Linearly interpolate between the two <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The starting <see cref="Vector2"/> value. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The ending <see cref="Vector2"/> value. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <param name="result">The interpolated <see cref="Vector2"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Lerp(ref Vector2 value1, ref Vector2 value2, float amount, out Vector2 result){
                    result.X = MathHelper.Lerp(value1.X, value2.X, amount);
result.Y = MathHelper.Lerp(value1.Y, value2.Y, amount);                }
            
                            /// <summary>Compute the maximum of each component of the <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. </param>
                /// <param name="value2">The second <see cref="Vector2"/>. </param>
                /// <returns>A <see cref="Vector2"/> containing the maximum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector2"/>'s components.</returns>
                public static Vector2 Max(Vector2 value1, Vector2 value2){ Vector2 result;
                    result.X = Math.Max(value1.X, value2.X);
result.Y = Math.Max(value1.Y, value2.Y);                return result; }
                            /// <summary>Compute the maximum of each component of the <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">A <see cref="Vector2"/> containing the maximum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector2"/>'s components. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Max(ref Vector2 value1, ref Vector2 value2, out Vector2 result){
                    result.X = Math.Max(value1.X, value2.X);
result.Y = Math.Max(value1.Y, value2.Y);                }
            

                            /// <summary>Compute the minimum of each component of the <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. </param>
                /// <param name="value2">The second <see cref="Vector2"/>. </param>
                /// <returns>A <see cref="Vector2"/> containing the minimum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector2"/>'s components.</returns>
                public static Vector2 Min(Vector2 value1, Vector2 value2){ Vector2 result;
                    result.X = Math.Min(value1.X, value2.X);
result.Y = Math.Min(value1.Y, value2.Y);                return result; }
                            /// <summary>Compute the minimum of each component of the <see cref="Vector2"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector2"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">A <see cref="Vector2"/> containing the minimum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector2"/>'s components. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Min(ref Vector2 value1, ref Vector2 value2, out Vector2 result){
                    result.X = Math.Min(value1.X, value2.X);
result.Y = Math.Min(value1.Y, value2.Y);                }
            
                            /// <summary>Compute the negative of each component of the <see cref="Vector2"/>.</summary>
                /// <param name="value">The <see cref="Vector2"/> to negate. </param>
                /// <returns>The negative <see cref="Vector2"/> value.</returns>
                public static Vector2 Negate(Vector2 value){ Vector2 result;
                    result.X = -value.X;
result.Y = -value.Y;                return result; }
                            /// <summary>Compute the negative of each component of the <see cref="Vector2"/>.</summary>
                /// <param name="value">The <see cref="Vector2"/> to negate. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The negative <see cref="Vector2"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Negate(ref Vector2 value, out Vector2 result){
                    result.X = -value.X;
result.Y = -value.Y;                }
            
                            /// <summary>Divide a <see cref="Vector2"/> by its <see cref="Length"/>, resulting in a <see cref="Vector2"/> with a <see cref="Length"/> of one. If the <see cref="Vector2"/>'s original <see cref="Length"/> is one, then the result's components will all be <c>float.NaN</c>.</summary>
                /// <param name="value">The <see cref="Vector2"/> to normalize. </param>
                /// <returns>The normalized (or invalid) <see cref="Vector2"/> value.</returns>
                public static Vector2 Normalize(Vector2 value){ Vector2 result;
                    float inverseLength = 1.0f / (float)Math.Sqrt(value.X * value.X + value.Y * value.Y);
                    result.X = value.X * inverseLength;
result.Y = value.Y * inverseLength;                return result; }
                            /// <summary>Divide a <see cref="Vector2"/> by its <see cref="Length"/>, resulting in a <see cref="Vector2"/> with a <see cref="Length"/> of one. If the <see cref="Vector2"/>'s original <see cref="Length"/> is one, then the result's components will all be <c>float.NaN</c>.</summary>
                /// <param name="value">The <see cref="Vector2"/> to normalize. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The normalized (or invalid) <see cref="Vector2"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Normalize(ref Vector2 value, out Vector2 result){
                    float inverseLength = 1.0f / (float)Math.Sqrt(value.X * value.X + value.Y * value.Y);
                    result.X = value.X * inverseLength;
result.Y = value.Y * inverseLength;                }
            
                                        /// <summary>Reflect a <see cref="Vector2"/> over a normal.</summary>
                /// <param name="vector">The <see cref="Vector2"/> to reflect. </param>
                /// <param name="normal">The normalized <see cref="Vector2"/> that is perpendicular to the surface to reflect off of.</param>
                /// <returns>The reflected <see cref="Vector2"/> value.</returns>
                public static Vector2 Reflect(Vector2 vector, Vector2 normal){ Vector2 result;
                    // I is the original ray
                    // N is the normal of the incident plane
                    // R = I - (2 * N * DotProduct[I, N])
                    float dotProduct = vector.X * normal.X + vector.Y * normal.Y;

                    result.X = vector.X - (2.0f * normal.X) * dotProduct;
result.Y = vector.Y - (2.0f * normal.Y) * dotProduct;                return result; }
                            /// <summary>Reflect a <see cref="Vector2"/> over a normal.</summary>
                /// <param name="vector">The <see cref="Vector2"/> to reflect. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="normal">The normalized <see cref="Vector2"/> that is perpendicular to the surface to reflect off of.</param>
                /// <param name="result">The reflected <see cref="Vector2"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Reflect(ref Vector2 vector, ref Vector2 normal, out Vector2 result){
                    // I is the original ray
                    // N is the normal of the incident plane
                    // R = I - (2 * N * DotProduct[I, N])
                    float dotProduct = vector.X * normal.X + vector.Y * normal.Y;

                    result.X = vector.X - (2.0f * normal.X) * dotProduct;
result.Y = vector.Y - (2.0f * normal.Y) * dotProduct;                }
            
                                        /// <summary>Interpolate using a <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> curve.</summary>
                /// <param name="value1">The start point. </param>
                /// <param name="value2">The end point. </param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <returns>The interpolated <see cref="Vector2"/> value.</returns>
                public static Vector2 SmoothStep(Vector2 value1, Vector2 value2, float amount){ Vector2 result;
                    result.X = MathHelper.SmoothStep(value1.X, value2.X, amount);
result.Y = MathHelper.SmoothStep(value1.Y, value2.Y, amount);                return result; }
                            /// <summary>Interpolate using a <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> curve.</summary>
                /// <param name="value1">The start point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The end point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <param name="result">The interpolated <see cref="Vector2"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void SmoothStep(ref Vector2 value1, ref Vector2 value2, float amount, out Vector2 result){
                    result.X = MathHelper.SmoothStep(value1.X, value2.X, amount);
result.Y = MathHelper.SmoothStep(value1.Y, value2.Y, amount);                }
            
                                        /// <summary>Transform the <see cref="Vector4"/> by the <see cref="Matrix"/>.</summary>
                /// <param name="position">The <see cref="Vector4"/> to transform. </param>
                /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. </param>
                /// <returns>The transformed <see cref="Vector4"/>.</returns>
                public static Vector2 Transform(Vector2 position, Matrix matrix){ Vector2 result;
                    result = new Vector2(
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M41
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M42
                                                
                            
                        );
                return result; }
                            /// <summary>Transform the <see cref="Vector4"/> by the <see cref="Matrix"/>.</summary>
                /// <param name="position">The <see cref="Vector4"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The transformed <see cref="Vector4"/>. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Transform(ref Vector2 position, ref Matrix matrix, out Vector2 result){
                    result = new Vector2(
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M41
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M42
                                                
                            
                        );
                }
            
                        
                        
                                                            /// <summary>Transforms a <see cref="Vector2"/> by a <see cref="Quaternion"/> rotation.</summary>
                    /// <param name="vector">The <see cref="Vector2"/> to transform. </param>
                    /// <param name="rotation">The <see cref="Quaternion"/> to rotate the <see cref="Vector2"/> by. </param>
                    /// <returns>The result of the transformation.</returns>
                    public static Vector2 Transform(Vector2 vector, Quaternion rotation){ Vector2 result;
                        float vz = 0f;
                        float x = 2 * (rotation.Y * vz - rotation.Z * vector.Y);
                        float y = 2 * (rotation.Z * vector.X - rotation.X * vz);
                        float z = 2 * (rotation.X * vector.Y - rotation.Y * vector.X);

                        result.X = vector.X + x * rotation.W + (rotation.Y * z - rotation.Z * y);
                        result.Y = vector.Y + y * rotation.W + (rotation.Z * x - rotation.X * z);
                                            return result; }
                                    /// <summary>Transforms a <see cref="Vector2"/> by a <see cref="Quaternion"/> rotation.</summary>
                    /// <param name="vector">The <see cref="Vector2"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="rotation">The <see cref="Quaternion"/> to rotate the <see cref="Vector2"/> by. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="result">The result of the transformation. The parameter may point to any member of the other parameters without affecting the result.</param>
                    public static void Transform(ref Vector2 vector, ref Quaternion rotation, out Vector2 result){
                        float vz = 0f;
                        float x = 2 * (rotation.Y * vz - rotation.Z * vector.Y);
                        float y = 2 * (rotation.Z * vector.X - rotation.X * vz);
                        float z = 2 * (rotation.X * vector.Y - rotation.Y * vector.X);

                        result.X = vector.X + x * rotation.W + (rotation.Y * z - rotation.Z * y);
                        result.Y = vector.Y + y * rotation.W + (rotation.Z * x - rotation.X * z);
                                            }
                            
            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <see cref="Vector2"/> values. The arrays may be the same.</summary>
            /// <param name="sourceArray">The array of <see cref="Vector2"/> values to transform.</param>
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <see cref="Vector2"/> values by.</param>
            /// <param name="destinationArray">The array to store transformed <see cref="Vector2"/> values in.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="sourceArray"/>'s <see cref="Array.Length"/> is greater than <paramref name="destinationArray"/>'s <see cref="Array.Length"/></exception>
            public static void Transform(Vector2[] sourceArray, ref Matrix matrix, Vector2[] destinationArray)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                Transform(sourceArray, 0, ref matrix, destinationArray, 0, sourceArray.Length);
            }

            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <see cref="Vector2"/> values. The arrays may be the same and the regions may overlap.</summary>
            /// <param name="sourceArray">The array of <see cref="Vector2"/> values to transform.</param>
            /// <param name="sourceIndex">The index of the first element of <paramref name="sourceArray"/> to transform.</param> 
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <see cref="Vector2"/> values by.</param>
            /// <param name="destinationArray">The array to store transformed <see cref="Vector2"/> values in.</param>
            /// <param name="destinationIndex">The index of the first element of <paramref name="destinationArray"/> to write to.</param>
            /// <param name="length">The number of <see cref="Vector2"/> values to transform.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/>, <paramref name="sourceIndex"/>, or <paramref name="destinationIndex"/> are below zero; or else the range given by <c><paramref name="sourceIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="sourceArray"/>; or else the range given by <c><paramref name="destinationIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="destinationArray"/>.</exception>
            public static void Transform(
                Vector2[] sourceArray,
                int sourceIndex,
                ref Matrix matrix,
                Vector2[] destinationArray,
                int destinationIndex,
                int length)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                if (destinationArray == null)
                    throw new ArgumentNullException("destinationArray");
                if (length < 0)
                    throw new ArgumentOutOfRangeException("length");
                if (sourceIndex < 0 || sourceIndex + length > sourceArray.Length)
                    throw new ArgumentOutOfRangeException("sourceIndex");
                if (destinationIndex < 0 || destinationIndex + length > destinationArray.Length)
                    throw new ArgumentOutOfRangeException("destinationIndex");

                // See whether we might need to iterate backwards.
                if (object.ReferenceEquals(sourceArray, destinationArray) && sourceIndex < destinationIndex)
                {
                    // We might need to iterate backwards, or else we'll overwrite source vertices before they're transformed.
                    // This is a "might" because we don't check for overlap, we just play it safe.
                    for (int index = length - 1; index >= 0; index--)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
                else
                {
                    for (int index = 0; index < length; index++)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
            }

                            /// <summary>Apply a <see cref="Quaternion"/> transform to an array of <see cref="Vector2"/> values. The arrays may be the same.</summary>
                /// <param name="sourceArray">The array of <see cref="Vector2"/> values to transform.</param>
                /// <param name="rotation">The <see cref="Quaternion"/> to transform the <see cref="Vector2"/> values by.</param>
                /// <param name="destinationArray">The array to store transformed <see cref="Vector2"/> values in.</param>
                /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
                /// <exception cref="ArgumentOutOfRangeException"><paramref name="sourceArray"/>'s <see cref="Array.Length"/> is greater than <paramref name="destinationArray"/>'s <see cref="Array.Length"/></exception>
                public static void Transform(Vector2[] sourceArray, ref Quaternion rotation, Vector2[] destinationArray)
                {
                    if (sourceArray == null)
                        throw new ArgumentNullException("sourceArray");
                    Transform(sourceArray, 0, ref rotation, destinationArray, 0, sourceArray.Length);
                }

                /// <summary>Apply a <see cref="Quaternion"/> transform to an array of <see cref="Vector2"/> values. The arrays may be the same and the regions may overlap.</summary>
                /// <param name="sourceArray">The array of <see cref="Vector2"/> values to transform.</param>
                /// <param name="sourceIndex">The index of the first element of <paramref name="sourceArray"/> to transform.</param> 
                /// <param name="rotation">The <see cref="Quaternion"/> to transform the <see cref="Vector2"/> values by.</param>
                /// <param name="destinationArray">The array to store transformed <see cref="Vector2"/> values in.</param>
                /// <param name="destinationIndex">The index of the first element of <paramref name="destinationArray"/> to write to.</param>
                /// <param name="length">The number of <see cref="Vector2"/> values to transform.</param>
                /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
                /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/>, <paramref name="sourceIndex"/>, or <paramref name="destinationIndex"/> are below zero; or else the range given by <c><paramref name="sourceIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="sourceArray"/>; or else the range given by <c><paramref name="destinationIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="destinationArray"/>.</exception>
                public static void Transform(
                    Vector2[] sourceArray,
                    int sourceIndex,
                    ref Quaternion rotation,
                    Vector2[] destinationArray,
                    int destinationIndex,
                    int length)
                {
                    if (sourceArray == null)
                        throw new ArgumentNullException("sourceArray");
                    if (destinationArray == null)
                        throw new ArgumentNullException("destinationArray");
                    if (length < 0)
                        throw new ArgumentOutOfRangeException("length");
                    if (sourceIndex < 0 || sourceIndex + length > sourceArray.Length)
                        throw new ArgumentOutOfRangeException("sourceIndex");
                    if (destinationIndex < 0 || destinationIndex + length > destinationArray.Length)
                        throw new ArgumentOutOfRangeException("destinationIndex");

                    // See whether we might need to iterate backwards.
                    if (object.ReferenceEquals(sourceArray, destinationArray) && sourceIndex < destinationIndex)
                    {
                        // We might need to iterate backwards, or else we'll overwrite source vertices before they're transformed.
                        // This is a "might" because we don't check for overlap, we just play it safe.
                        for (int index = length - 1; index >= 0; index--)
                            Transform(ref sourceArray[sourceIndex + index], ref rotation, out destinationArray[destinationIndex + index]);
                    }
                    else
                    {
                        for (int index = 0; index < length; index++)
                            Transform(ref sourceArray[sourceIndex + index], ref rotation, out destinationArray[destinationIndex + index]);
                    }
                }
            
                                                            /// <summary>Transform the <see cref="Vector2"/> by a <see cref="Matrix"/>, ignoring the translation component of the <see cref="Matrix"/>. The input and the results are not normalized.</summary>
                    /// <param name="position">The <see cref="Vector2"/> to transform. </param>
                    /// <param name="matrix">The transformation <see cref="Matrix"/>. </param>
                    /// <returns>The transformed <see cref="Vector2"/> normal.</returns>
                    public static Vector2 TransformNormal(Vector2 position, Matrix matrix){ Vector2 result;
                        result = new Vector2(                            // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22
                                                
                            
                        );
                    return result; }
                                    /// <summary>Transform the <see cref="Vector2"/> by a <see cref="Matrix"/>, ignoring the translation component of the <see cref="Matrix"/>. The input and the results are not normalized.</summary>
                    /// <param name="position">The <see cref="Vector2"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="matrix">The transformation <see cref="Matrix"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="result">The transformed <see cref="Vector2"/> normal. The parameter may point to any member of the other parameters without affecting the result.</param>
                    public static void TransformNormal(ref Vector2 position, ref Matrix matrix, out Vector2 result){
                        result = new Vector2(                            // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22
                                                
                            
                        );
                    }
                            
            #endregion Public static methods

            #region Public methods

            /// <summary>Determine whether this <see cref="Vector2"/> and the other are equivalent, which is only possible if <paramref name="obj"/> is a <see cref="Vector2"/> with equivalent axes.</summary>
            /// <param name="obj">The object to compare to.</param>
            /// <returns>Whether the objects are equivalent.</returns>
            public override bool Equals(object obj)
            {
			    if(obj is Vector2)
			    {
                    Vector2 other = (Vector2)obj;
                    return X == other.X && Y == other.Y;
			    }
			
                return false;
            }

            /// <summary>Determine whether this <see cref="Vector2"/> and the other <see cref="Vector2"/> are equivalent in all components.</summary>
            /// <param name="other">The <see cref="Vector2"/> to compare to.</param>
            /// <returns>Whether the <see cref="Vector2"/> values are equivalent.</returns>
            public bool Equals(Vector2 other)
            {
                return X == other.X && Y == other.Y;
            }

            /// <summary>Get a hash code value that is as different from other, similiar <see cref="Vector2"/> as possible.</summary>
            /// <returns>The hash code value.</returns>
            public override int GetHashCode()
            {
                return X.GetHashCode() * 31 ^ Y.GetHashCode() * 31;
            }

            /// <summary>Compute the length of the <see cref="Vector2"/>, which is the distance from the origin.</summary>
            /// <returns>The length of the <see cref="Vector2"/>.</returns>
            public float Length()
            {
                return (float)Math.Sqrt(X * X + Y * Y);
            }

            /// <summary>Compute the squared length of the <see cref="Vector2"/>, which is the squared distance from the origin. The squared length avoids a square root over <see cref="Length"/>, which is therefore faster.</summary>
            /// <returns>The squared length of the <see cref="Vector2"/>.</returns>
            public float LengthSquared()
            {
                return X * X + Y * Y;
            }

            /// <summary>Divide the <see cref="Vector2"/> by its <see cref="Length"/> so that its <see cref="Length"/> is one. If its original length is 0, then all components will be set to <c>float.NaN</c>.</summary>
            public void Normalize()
            {
                float inverseLength = 1.0f / (float)Math.Sqrt(X * X + Y * Y);
                X *= inverseLength;
Y *= inverseLength;            }

            /// <summary>Convert to a string of the form "{X:x Y:y}".</summary>
            /// <returns>The string representation of this <see cref="Vector2"/>.</returns>
            public override string ToString()
            {
                CultureInfo currentCulture = CultureInfo.CurrentCulture;
                return string.Format(currentCulture, "{{X:{0} Y:{1}}}", new object[] { X.ToString(currentCulture), Y.ToString(currentCulture) });
            }

            #endregion Public methods

            #region Operators and operator methods

            /// <summary>Compute the negative of the value (which is the value).</summary>
            /// <param name="value">The <see cref="Vector2"/>.</param>
            /// <returns>The <see cref="Vector2"/>.</returns>
            public static Vector2 operator +(Vector2 value)
            {
                value.X = +value.X;
value.Y = +value.Y;                return value;
            }

            /// <summary>Compute the negative of the value.</summary>
            /// <param name="value">The <see cref="Vector2"/> to negate.</param>
            /// <returns>The negated <see cref="Vector2"/>.</returns>
            public static Vector2 operator -(Vector2 value)
            {
                value.X = -value.X;
value.Y = -value.Y;                return value;
            }

            /// <summary>Compute whether the two <see cref="Vector2"/> values are equal.</summary>
            /// <param name="value1">The first <see cref="Vector2"/> to compare.</param>
            /// <param name="value2">The second <see cref="Vector2"/> to compare.</param>
            /// <returns>Whether the <see cref="Vector2"/> values are equal.</returns>
            public static bool operator ==(Vector2 value1, Vector2 value2)
            {
                return value1.X == value2.X&&value1.Y == value2.Y;
            }

            /// <summary>Compute whether the two <see cref="Vector2"/> values are not equal.</summary>
            /// <param name="value1">The first <see cref="Vector2"/> to compare.</param>
            /// <param name="value2">The second <see cref="Vector2"/> to compare.</param>
            /// <returns>Whether the <see cref="Vector2"/> values are not equal.</returns>
            public static bool operator !=(Vector2 value1, Vector2 value2)
            {
                return value1.X != value2.X||value1.Y != value2.Y;
            }

                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Add the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Add(Vector2 value1, Vector2 value2){ Vector2 result;
                    result.X = value1.X + value2.X;
result.Y = value1.Y + value2.Y;                return result; }
                                /// <summary>Add the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(ref Vector2 value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1.X + value2.X;
result.Y = value1.Y + value2.Y;                }
                
                                /// <summary>AddThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Add(Vector2 value1, float value2){ Vector2 result;
                    result.X = value1.X + value2;
result.Y = value1.Y + value2;                return result; }
                                /// <summary>AddThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(ref Vector2 value1, float value2, out Vector2 result){
                    result.X = value1.X + value2;
result.Y = value1.Y + value2;                }
                
                                /// <summary>AddThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Add(float value1, Vector2 value2){ Vector2 result;
                    result.X = value1 + value2.X;
result.Y = value1 + value2.Y;                return result; }
                                /// <summary>AddThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(float value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1 + value2.X;
result.Y = value1 + value2.Y;                }
                
                /// <summary>Add the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator +(Vector2 value1, Vector2 value2)
                {
                    value1.X += value2.X;
value1.Y += value2.Y;                    return value1;
                }

                /// <summary>Add the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator +(Vector2 value1, float value2)
                {
                    value1.X += value2;
value1.Y += value2;                    return value1;
                }

                /// <summary>Add the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator +(float value1, Vector2 value2)
                {
                    value2.X = value1 + value2.X;
value2.Y = value1 + value2.Y;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Subtract the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Subtract(Vector2 value1, Vector2 value2){ Vector2 result;
                    result.X = value1.X - value2.X;
result.Y = value1.Y - value2.Y;                return result; }
                                /// <summary>Subtract the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(ref Vector2 value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1.X - value2.X;
result.Y = value1.Y - value2.Y;                }
                
                                /// <summary>SubtractThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Subtract(Vector2 value1, float value2){ Vector2 result;
                    result.X = value1.X - value2;
result.Y = value1.Y - value2;                return result; }
                                /// <summary>SubtractThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(ref Vector2 value1, float value2, out Vector2 result){
                    result.X = value1.X - value2;
result.Y = value1.Y - value2;                }
                
                                /// <summary>SubtractThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Subtract(float value1, Vector2 value2){ Vector2 result;
                    result.X = value1 - value2.X;
result.Y = value1 - value2.Y;                return result; }
                                /// <summary>SubtractThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(float value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1 - value2.X;
result.Y = value1 - value2.Y;                }
                
                /// <summary>Subtract the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator -(Vector2 value1, Vector2 value2)
                {
                    value1.X -= value2.X;
value1.Y -= value2.Y;                    return value1;
                }

                /// <summary>Subtract the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator -(Vector2 value1, float value2)
                {
                    value1.X -= value2;
value1.Y -= value2;                    return value1;
                }

                /// <summary>Subtract the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator -(float value1, Vector2 value2)
                {
                    value2.X = value1 - value2.X;
value2.Y = value1 - value2.Y;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Multiply the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Multiply(Vector2 value1, Vector2 value2){ Vector2 result;
                    result.X = value1.X * value2.X;
result.Y = value1.Y * value2.Y;                return result; }
                                /// <summary>Multiply the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(ref Vector2 value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1.X * value2.X;
result.Y = value1.Y * value2.Y;                }
                
                                /// <summary>MultiplyThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Multiply(Vector2 value1, float value2){ Vector2 result;
                    result.X = value1.X * value2;
result.Y = value1.Y * value2;                return result; }
                                /// <summary>MultiplyThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(ref Vector2 value1, float value2, out Vector2 result){
                    result.X = value1.X * value2;
result.Y = value1.Y * value2;                }
                
                                /// <summary>MultiplyThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Multiply(float value1, Vector2 value2){ Vector2 result;
                    result.X = value1 * value2.X;
result.Y = value1 * value2.Y;                return result; }
                                /// <summary>MultiplyThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(float value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1 * value2.X;
result.Y = value1 * value2.Y;                }
                
                /// <summary>Multiply the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator *(Vector2 value1, Vector2 value2)
                {
                    value1.X *= value2.X;
value1.Y *= value2.Y;                    return value1;
                }

                /// <summary>Multiply the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator *(Vector2 value1, float value2)
                {
                    value1.X *= value2;
value1.Y *= value2;                    return value1;
                }

                /// <summary>Multiply the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator *(float value1, Vector2 value2)
                {
                    value2.X = value1 * value2.X;
value2.Y = value1 * value2.Y;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Divide the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Divide(Vector2 value1, Vector2 value2){ Vector2 result;
                    result.X = value1.X / value2.X;
result.Y = value1.Y / value2.Y;                return result; }
                                /// <summary>Divide the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(ref Vector2 value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1.X / value2.X;
result.Y = value1.Y / value2.Y;                }
                
                                /// <summary>DivideThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Divide(Vector2 value1, float value2){ Vector2 result;
                    result.X = value1.X / value2;
result.Y = value1.Y / value2;                return result; }
                                /// <summary>DivideThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(ref Vector2 value1, float value2, out Vector2 result){
                    result.X = value1.X / value2;
result.Y = value1.Y / value2;                }
                
                                /// <summary>DivideThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Divide(float value1, Vector2 value2){ Vector2 result;
                    result.X = value1 / value2.X;
result.Y = value1 / value2.Y;                return result; }
                                /// <summary>DivideThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(float value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1 / value2.X;
result.Y = value1 / value2.Y;                }
                
                /// <summary>Divide the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator /(Vector2 value1, Vector2 value2)
                {
                    value1.X /= value2.X;
value1.Y /= value2.Y;                    return value1;
                }

                /// <summary>Divide the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator /(Vector2 value1, float value2)
                {
                    value1.X /= value2;
value1.Y /= value2;                    return value1;
                }

                /// <summary>Divide the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator /(float value1, Vector2 value2)
                {
                    value2.X = value1 / value2.X;
value2.Y = value1 / value2.Y;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Modulo the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Modulo(Vector2 value1, Vector2 value2){ Vector2 result;
                    result.X = value1.X % value2.X;
result.Y = value1.Y % value2.Y;                return result; }
                                /// <summary>Modulo the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(ref Vector2 value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1.X % value2.X;
result.Y = value1.Y % value2.Y;                }
                
                                /// <summary>ModuloThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Modulo(Vector2 value1, float value2){ Vector2 result;
                    result.X = value1.X % value2;
result.Y = value1.Y % value2;                return result; }
                                /// <summary>ModuloThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector2"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(ref Vector2 value1, float value2, out Vector2 result){
                    result.X = value1.X % value2;
result.Y = value1.Y % value2;                }
                
                                /// <summary>ModuloThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 Modulo(float value1, Vector2 value2){ Vector2 result;
                    result.X = value1 % value2.X;
result.Y = value1 % value2.Y;                return result; }
                                /// <summary>ModuloThe components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector2"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(float value1, ref Vector2 value2, out Vector2 result){
                    result.X = value1 % value2.X;
result.Y = value1 % value2.Y;                }
                
                /// <summary>Modulo the components of the <see cref="Vector2"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator %(Vector2 value1, Vector2 value2)
                {
                    value1.X %= value2.X;
value1.Y %= value2.Y;                    return value1;
                }

                /// <summary>Modulo the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator %(Vector2 value1, float value2)
                {
                    value1.X %= value2;
value1.Y %= value2;                    return value1;
                }

                /// <summary>Modulo the components of a <see cref="Vector2"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector2 operator %(float value1, Vector2 value2)
                {
                    value2.X = value1 % value2.X;
value2.Y = value1 % value2.Y;                    return value2;
                }
            
            #endregion Operators and operator methods
        }

                    
        
        /// <summary>A three-dimensional floating-point <a href="http://en.wikipedia.org/wiki/Column_vector">column vector</a>.</summary>
        [DataContract]
        partial struct Vector3 : IEquatable<Vector3>
        {
            #region Private fields

            // Implementation note: These constants cannot be "readonly" because they are passed by reference in the implementation.

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static Vector3 zero = new Vector3(0f, 0f, 0f);

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static Vector3 one = new Vector3(1f, 1f, 1f);

                            /// <summary>Backing field of the <see cref="UnitX"/> property.</summary>
                private static Vector3 unitX = new Vector3(1f, 0f, 0f);
                            /// <summary>Backing field of the <see cref="UnitY"/> property.</summary>
                private static Vector3 unitY = new Vector3(0f, 1f, 0f);
                            /// <summary>Backing field of the <see cref="UnitZ"/> property.</summary>
                private static Vector3 unitZ = new Vector3(0f, 0f, 1f);
            
            #endregion Private fields

            #region Public fields

                            /// <summary>
                /// The first axis of the <see cref="Vector3"/>.
                /// </summary>
                [DataMember]
                public float X;
                            /// <summary>
                /// The second axis of the <see cref="Vector3"/>.
                /// </summary>
                [DataMember]
                public float Y;
                            /// <summary>
                /// The third axis of the <see cref="Vector3"/>.
                /// </summary>
                [DataMember]
                public float Z;
            
            #endregion Public fields

            #region Properties

            /// <summary>Get a <see cref="Vector3"/> where all of the components are zero.</summary>
            public static Vector3 Zero { get { return zero; } }

            /// <summary>Get a <see cref="Vector3"/> where all of the components are one.</summary>
            public static Vector3 One { get { return one; } }

                            /// <summary>Get a <see cref="Vector3"/> where the X component is one and the rest are zero.</summary>
                public static Vector3 UnitX { get { return unitX; } }
                            /// <summary>Get a <see cref="Vector3"/> where the Y component is one and the rest are zero.</summary>
                public static Vector3 UnitY { get { return unitY; } }
                            /// <summary>Get a <see cref="Vector3"/> where the Z component is one and the rest are zero.</summary>
                public static Vector3 UnitZ { get { return unitZ; } }
            
            #endregion Properties

            #region Constructors

            /// <summary>Initialize the components of the <see cref="Vector3"/>.</summary>
            /// <param name="x">Value for the <see cref="X"/> component.</param>
/// <param name="y">Value for the <see cref="Y"/> component.</param>
/// <param name="z">Value for the <see cref="Z"/> component.</param>
            public Vector3(float x, float y, float z)
            {
                X = x;
Y = y;
Z = z;            }

            /// <summary>Initialize the components of the Vector3 to the same value.</summary>
            /// <param name="value">The value to assign to the X, Y and Z components.</param>
            public Vector3(float value)
            {
                X = Y = Z = value;
            }

            #endregion Constructors

            #region Public static methods

                            /// <summary>For each component of the <see cref="Vector3"/>s, compute the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate">Cartesian coordinate</a> for a point that is defined by a given triangle and two normalized <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)">barycentric (areal) coordinates</a>.</summary>
                /// <remarks>The effect of barycentric coordinates is that <paramref name="amount1"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value2"/> and <paramref name="amount2"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value3"/>, with zero for either amount being <paramref name="amount1"/> and one being the opposite corner. These coordinates are not linear.</remarks>
                /// <seealso cref="MathHelper.Barycentric"/>
                /// <param name="value1">The first vertex of the triangle. </param>
                /// <param name="value2">The second vertex of the triangle. </param>
                /// <param name="value3">The third vertex of the triangle. </param>
                /// <param name="amount1">The second barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value2"/>.</param>
                /// <param name="amount2">The third barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value3"/>.</param>
                /// <returns>The point at the given barycentric coordinates.</returns>
                public static Vector3 Barycentric(Vector3 value1, Vector3 value2, Vector3 value3, float amount1, float amount2){ Vector3 result;
                    result.X = MathHelper.Barycentric(value1.X, value2.X, value3.X, amount1, amount2);
result.Y = MathHelper.Barycentric(value1.Y, value2.Y, value3.Y, amount1, amount2);
result.Z = MathHelper.Barycentric(value1.Z, value2.Z, value3.Z, amount1, amount2);                return result; }
                            /// <summary>For each component of the <see cref="Vector3"/>s, compute the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate">Cartesian coordinate</a> for a point that is defined by a given triangle and two normalized <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)">barycentric (areal) coordinates</a>.</summary>
                /// <remarks>The effect of barycentric coordinates is that <paramref name="amount1"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value2"/> and <paramref name="amount2"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value3"/>, with zero for either amount being <paramref name="amount1"/> and one being the opposite corner. These coordinates are not linear.</remarks>
                /// <seealso cref="MathHelper.Barycentric"/>
                /// <param name="value1">The first vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value3">The third vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount1">The second barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value2"/>.</param>
                /// <param name="amount2">The third barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value3"/>.</param>
                /// <param name="result">The point at the given barycentric coordinates. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Barycentric(ref Vector3 value1, ref Vector3 value2, ref Vector3 value3, float amount1, float amount2, out Vector3 result){
                    result.X = MathHelper.Barycentric(value1.X, value2.X, value3.X, amount1, amount2);
result.Y = MathHelper.Barycentric(value1.Y, value2.Y, value3.Y, amount1, amount2);
result.Z = MathHelper.Barycentric(value1.Z, value2.Z, value3.Z, amount1, amount2);                }
            
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Catmull-Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which passes through <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/>, and <paramref name="value4"/> as <paramref name="amount"/> increases from 0 to 1.</summary>
                /// <seealso cref="MathHelper.CatmullRom"/>
                /// <param name="value1">The first <see cref="Vector3"/> along the spline. </param>
                /// <param name="value2">The second <see cref="Vector3"/> along the spline. </param>
                /// <param name="value3">The third <see cref="Vector3"/> along the spline. </param>
                /// <param name="value4">The fourth <see cref="Vector3"/> along the spline. </param>
                /// <param name="amount">The amount to interpolate along the spline, generally between 0 and 1.</param>
                /// <returns>The interpolated point.</returns>
                public static Vector3 CatmullRom(Vector3 value1, Vector3 value2, Vector3 value3, Vector3 value4, float amount){ Vector3 result;
                    result.X = MathHelper.CatmullRom(value1.X, value2.X, value3.X, value4.X, amount);
result.Y = MathHelper.CatmullRom(value1.Y, value2.Y, value3.Y, value4.Y, amount);
result.Z = MathHelper.CatmullRom(value1.Z, value2.Z, value3.Z, value4.Z, amount);                return result; }
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Catmull-Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which passes through <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/>, and <paramref name="value4"/> as <paramref name="amount"/> increases from 0 to 1.</summary>
                /// <seealso cref="MathHelper.CatmullRom"/>
                /// <param name="value1">The first <see cref="Vector3"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector3"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value3">The third <see cref="Vector3"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value4">The fourth <see cref="Vector3"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate along the spline, generally between 0 and 1.</param>
                /// <param name="result">The interpolated point. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void CatmullRom(ref Vector3 value1, ref Vector3 value2, ref Vector3 value3, ref Vector3 value4, float amount, out Vector3 result){
                    result.X = MathHelper.CatmullRom(value1.X, value2.X, value3.X, value4.X, amount);
result.Y = MathHelper.CatmullRom(value1.Y, value2.Y, value3.Y, value4.Y, amount);
result.Z = MathHelper.CatmullRom(value1.Z, value2.Z, value3.Z, value4.Z, amount);                }
            
                            /// <summary>Restrict the components of the <see cref="Vector3"/> to upper and lower boundaries.</summary>
                /// <param name="value1">The value to clamp. </param>
                /// <param name="min">The lower boundary. </param>
                /// <param name="max">The upper boundary. </param>
                /// <returns>The clamped value.</returns>
                public static Vector3 Clamp(Vector3 value1, Vector3 min, Vector3 max){ Vector3 result;
                    result.X = MathHelper.Clamp(value1.X, min.X, max.X);
result.Y = MathHelper.Clamp(value1.Y, min.Y, max.Y);
result.Z = MathHelper.Clamp(value1.Z, min.Z, max.Z);                return result; }
                            /// <summary>Restrict the components of the <see cref="Vector3"/> to upper and lower boundaries.</summary>
                /// <param name="value1">The value to clamp. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="min">The lower boundary. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="max">The upper boundary. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The clamped value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Clamp(ref Vector3 value1, ref Vector3 min, ref Vector3 max, out Vector3 result){
                    result.X = MathHelper.Clamp(value1.X, min.X, max.X);
result.Y = MathHelper.Clamp(value1.Y, min.Y, max.Y);
result.Z = MathHelper.Clamp(value1.Z, min.Z, max.Z);                }
            
                            /// <summary>Compute the distance between the two <see cref="Vector3"/>.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. </param>
                /// <param name="value2">The second <see cref="Vector3"/>. </param>
                /// <returns>The distance between the two <see cref="Vector3"/> objects.</returns>
                public static float Distance(Vector3 value1, Vector3 value2){ float result;
                    float X = value2.X - value1.X, Y = value2.Y - value1.Y, Z = value2.Z - value1.Z;
                    result = (float)Math.Sqrt(X * X + Y * Y + Z * Z);
                return result; }
                            /// <summary>Compute the distance between the two <see cref="Vector3"/>.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The distance between the two <see cref="Vector3"/> objects. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Distance(ref Vector3 value1, ref Vector3 value2, out float result){
                    float X = value2.X - value1.X, Y = value2.Y - value1.Y, Z = value2.Z - value1.Z;
                    result = (float)Math.Sqrt(X * X + Y * Y + Z * Z);
                }
            
                            /// <summary>Compute the squared distance between the two <see cref="Vector3"/>, which saves a square root over <see cref="Distance(Vector3,Vector3)"/></summary>
                /// <param name="value1">The first <see cref="Vector3"/>. </param>
                /// <param name="value2">The second <see cref="Vector3"/>. </param>
                /// <returns>The squared distance between the two <see cref="Vector3"/> values.</returns>
                public static float DistanceSquared(Vector3 value1, Vector3 value2){ float result;
                    float x = value2.X - value1.X, y = value2.Y - value1.Y, z = value2.Z - value1.Z;
                    result = x * x + y * y + z * z;
                return result; }
                            /// <summary>Compute the squared distance between the two <see cref="Vector3"/>, which saves a square root over <see cref="Distance(Vector3,Vector3)"/></summary>
                /// <param name="value1">The first <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The squared distance between the two <see cref="Vector3"/> values. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void DistanceSquared(ref Vector3 value1, ref Vector3 value2, out float result){
                    float x = value2.X - value1.X, y = value2.Y - value1.Y, z = value2.Z - value1.Z;
                    result = x * x + y * y + z * z;
                }
            
                            /// <summary>Compute the <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> of the two <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. </param>
                /// <param name="value2">The second <see cref="Vector3"/>. </param>
                /// <returns>The dot product of the parameters.</returns>
                public static float Dot(Vector3 value1, Vector3 value2){ float result;
                    result = value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
                return result; }
                            /// <summary>Compute the <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> of the two <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The dot product of the parameters. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Dot(ref Vector3 value1, ref Vector3 value2, out float result){
                    result = value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z;
                }
            
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>.</summary>
                /// <param name="value1">The starting point.</param>
                /// <param name="tangent1">The tangent (the direction) of the spline at the start. </param>
                /// <param name="value2">The ending point. </param>
                /// <param name="tangent2">The tangent (the direction) of the spline at the end. </param>
                /// <param name="amount">The amount to interpolate on the curve between <paramref name="value1"/> (at <c>0.0f</c>) and <paramref name="value2"/> (at <c>1.0f</c>).</param>
                /// <returns>The interpolated value.</returns>
                public static Vector3 Hermite(Vector3 value1, Vector3 tangent1, Vector3 value2, Vector3 tangent2, float amount){ Vector3 result;
                    result.X = MathHelper.Hermite(value1.X, tangent1.X, value2.X, tangent2.X, amount);
result.Y = MathHelper.Hermite(value1.Y, tangent1.Y, value2.Y, tangent2.Y, amount);
result.Z = MathHelper.Hermite(value1.Z, tangent1.Z, value2.Z, tangent2.Z, amount);                return result; }
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>.</summary>
                /// <param name="value1">The starting point.</param>
                /// <param name="tangent1">The tangent (the direction) of the spline at the start. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The ending point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="tangent2">The tangent (the direction) of the spline at the end. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate on the curve between <paramref name="value1"/> (at <c>0.0f</c>) and <paramref name="value2"/> (at <c>1.0f</c>).</param>
                /// <param name="result">The interpolated value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Hermite(ref Vector3 value1, ref Vector3 tangent1, ref Vector3 value2, ref Vector3 tangent2, float amount, out Vector3 result){
                    result.X = MathHelper.Hermite(value1.X, tangent1.X, value2.X, tangent2.X, amount);
result.Y = MathHelper.Hermite(value1.Y, tangent1.Y, value2.Y, tangent2.Y, amount);
result.Z = MathHelper.Hermite(value1.Z, tangent1.Z, value2.Z, tangent2.Z, amount);                }
            
                            /// <summary>Linearly interpolate between the two <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The starting <see cref="Vector3"/> value. </param>
                /// <param name="value2">The ending <see cref="Vector3"/> value. </param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <returns>The interpolated <see cref="Vector3"/> value.</returns>
                public static Vector3 Lerp(Vector3 value1, Vector3 value2, float amount){ Vector3 result;
                    result.X = MathHelper.Lerp(value1.X, value2.X, amount);
result.Y = MathHelper.Lerp(value1.Y, value2.Y, amount);
result.Z = MathHelper.Lerp(value1.Z, value2.Z, amount);                return result; }
                            /// <summary>Linearly interpolate between the two <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The starting <see cref="Vector3"/> value. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The ending <see cref="Vector3"/> value. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <param name="result">The interpolated <see cref="Vector3"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Lerp(ref Vector3 value1, ref Vector3 value2, float amount, out Vector3 result){
                    result.X = MathHelper.Lerp(value1.X, value2.X, amount);
result.Y = MathHelper.Lerp(value1.Y, value2.Y, amount);
result.Z = MathHelper.Lerp(value1.Z, value2.Z, amount);                }
            
                            /// <summary>Compute the maximum of each component of the <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. </param>
                /// <param name="value2">The second <see cref="Vector3"/>. </param>
                /// <returns>A <see cref="Vector3"/> containing the maximum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector3"/>'s components.</returns>
                public static Vector3 Max(Vector3 value1, Vector3 value2){ Vector3 result;
                    result.X = Math.Max(value1.X, value2.X);
result.Y = Math.Max(value1.Y, value2.Y);
result.Z = Math.Max(value1.Z, value2.Z);                return result; }
                            /// <summary>Compute the maximum of each component of the <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">A <see cref="Vector3"/> containing the maximum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector3"/>'s components. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Max(ref Vector3 value1, ref Vector3 value2, out Vector3 result){
                    result.X = Math.Max(value1.X, value2.X);
result.Y = Math.Max(value1.Y, value2.Y);
result.Z = Math.Max(value1.Z, value2.Z);                }
            

                            /// <summary>Compute the minimum of each component of the <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. </param>
                /// <param name="value2">The second <see cref="Vector3"/>. </param>
                /// <returns>A <see cref="Vector3"/> containing the minimum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector3"/>'s components.</returns>
                public static Vector3 Min(Vector3 value1, Vector3 value2){ Vector3 result;
                    result.X = Math.Min(value1.X, value2.X);
result.Y = Math.Min(value1.Y, value2.Y);
result.Z = Math.Min(value1.Z, value2.Z);                return result; }
                            /// <summary>Compute the minimum of each component of the <see cref="Vector3"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">A <see cref="Vector3"/> containing the minimum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector3"/>'s components. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Min(ref Vector3 value1, ref Vector3 value2, out Vector3 result){
                    result.X = Math.Min(value1.X, value2.X);
result.Y = Math.Min(value1.Y, value2.Y);
result.Z = Math.Min(value1.Z, value2.Z);                }
            
                            /// <summary>Compute the negative of each component of the <see cref="Vector3"/>.</summary>
                /// <param name="value">The <see cref="Vector3"/> to negate. </param>
                /// <returns>The negative <see cref="Vector3"/> value.</returns>
                public static Vector3 Negate(Vector3 value){ Vector3 result;
                    result.X = -value.X;
result.Y = -value.Y;
result.Z = -value.Z;                return result; }
                            /// <summary>Compute the negative of each component of the <see cref="Vector3"/>.</summary>
                /// <param name="value">The <see cref="Vector3"/> to negate. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The negative <see cref="Vector3"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Negate(ref Vector3 value, out Vector3 result){
                    result.X = -value.X;
result.Y = -value.Y;
result.Z = -value.Z;                }
            
                            /// <summary>Divide a <see cref="Vector3"/> by its <see cref="Length"/>, resulting in a <see cref="Vector3"/> with a <see cref="Length"/> of one. If the <see cref="Vector3"/>'s original <see cref="Length"/> is one, then the result's components will all be <c>float.NaN</c>.</summary>
                /// <param name="value">The <see cref="Vector3"/> to normalize. </param>
                /// <returns>The normalized (or invalid) <see cref="Vector3"/> value.</returns>
                public static Vector3 Normalize(Vector3 value){ Vector3 result;
                    float inverseLength = 1.0f / (float)Math.Sqrt(value.X * value.X + value.Y * value.Y + value.Z * value.Z);
                    result.X = value.X * inverseLength;
result.Y = value.Y * inverseLength;
result.Z = value.Z * inverseLength;                return result; }
                            /// <summary>Divide a <see cref="Vector3"/> by its <see cref="Length"/>, resulting in a <see cref="Vector3"/> with a <see cref="Length"/> of one. If the <see cref="Vector3"/>'s original <see cref="Length"/> is one, then the result's components will all be <c>float.NaN</c>.</summary>
                /// <param name="value">The <see cref="Vector3"/> to normalize. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The normalized (or invalid) <see cref="Vector3"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Normalize(ref Vector3 value, out Vector3 result){
                    float inverseLength = 1.0f / (float)Math.Sqrt(value.X * value.X + value.Y * value.Y + value.Z * value.Z);
                    result.X = value.X * inverseLength;
result.Y = value.Y * inverseLength;
result.Z = value.Z * inverseLength;                }
            
                                        /// <summary>Reflect a <see cref="Vector3"/> over a normal.</summary>
                /// <param name="vector">The <see cref="Vector3"/> to reflect. </param>
                /// <param name="normal">The normalized <see cref="Vector3"/> that is perpendicular to the surface to reflect off of.</param>
                /// <returns>The reflected <see cref="Vector3"/> value.</returns>
                public static Vector3 Reflect(Vector3 vector, Vector3 normal){ Vector3 result;
                    // I is the original ray
                    // N is the normal of the incident plane
                    // R = I - (2 * N * DotProduct[I, N])
                    float dotProduct = vector.X * normal.X + vector.Y * normal.Y + vector.Z * normal.Z;

                    result.X = vector.X - (2.0f * normal.X) * dotProduct;
result.Y = vector.Y - (2.0f * normal.Y) * dotProduct;
result.Z = vector.Z - (2.0f * normal.Z) * dotProduct;                return result; }
                            /// <summary>Reflect a <see cref="Vector3"/> over a normal.</summary>
                /// <param name="vector">The <see cref="Vector3"/> to reflect. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="normal">The normalized <see cref="Vector3"/> that is perpendicular to the surface to reflect off of.</param>
                /// <param name="result">The reflected <see cref="Vector3"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Reflect(ref Vector3 vector, ref Vector3 normal, out Vector3 result){
                    // I is the original ray
                    // N is the normal of the incident plane
                    // R = I - (2 * N * DotProduct[I, N])
                    float dotProduct = vector.X * normal.X + vector.Y * normal.Y + vector.Z * normal.Z;

                    result.X = vector.X - (2.0f * normal.X) * dotProduct;
result.Y = vector.Y - (2.0f * normal.Y) * dotProduct;
result.Z = vector.Z - (2.0f * normal.Z) * dotProduct;                }
            
                                        /// <summary>Interpolate using a <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> curve.</summary>
                /// <param name="value1">The start point. </param>
                /// <param name="value2">The end point. </param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <returns>The interpolated <see cref="Vector3"/> value.</returns>
                public static Vector3 SmoothStep(Vector3 value1, Vector3 value2, float amount){ Vector3 result;
                    result.X = MathHelper.SmoothStep(value1.X, value2.X, amount);
result.Y = MathHelper.SmoothStep(value1.Y, value2.Y, amount);
result.Z = MathHelper.SmoothStep(value1.Z, value2.Z, amount);                return result; }
                            /// <summary>Interpolate using a <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> curve.</summary>
                /// <param name="value1">The start point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The end point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <param name="result">The interpolated <see cref="Vector3"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void SmoothStep(ref Vector3 value1, ref Vector3 value2, float amount, out Vector3 result){
                    result.X = MathHelper.SmoothStep(value1.X, value2.X, amount);
result.Y = MathHelper.SmoothStep(value1.Y, value2.Y, amount);
result.Z = MathHelper.SmoothStep(value1.Z, value2.Z, amount);                }
            
                                        /// <summary>Transform the <see cref="Vector4"/> by the <see cref="Matrix"/>.</summary>
                /// <param name="position">The <see cref="Vector4"/> to transform. </param>
                /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. </param>
                /// <returns>The transformed <see cref="Vector4"/>.</returns>
                public static Vector3 Transform(Vector3 position, Matrix matrix){ Vector3 result;
                    result = new Vector3(
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21 + 
                                                            position.Z * matrix.M31
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M41
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22 + 
                                                            position.Z * matrix.M32
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M42
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M13 + 
                                                            position.Y * matrix.M23 + 
                                                            position.Z * matrix.M33
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M43
                                                
                            
                        );
                return result; }
                            /// <summary>Transform the <see cref="Vector4"/> by the <see cref="Matrix"/>.</summary>
                /// <param name="position">The <see cref="Vector4"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The transformed <see cref="Vector4"/>. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Transform(ref Vector3 position, ref Matrix matrix, out Vector3 result){
                    result = new Vector3(
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21 + 
                                                            position.Z * matrix.M31
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M41
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22 + 
                                                            position.Z * matrix.M32
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M42
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M13 + 
                                                            position.Y * matrix.M23 + 
                                                            position.Z * matrix.M33
                            
                            // One-extend the W axis of vector types below order 4.
                                                            + matrix.M43
                                                
                            
                        );
                }
            
                                                            /// <summary>Transform a <see cref="Vector2"/> by a <see cref="Matrix"/>, extending the <see cref="Vector2"/> to produce a <see cref="Z"/> value of 0 and a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector2"/> to transform. </param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector3"/>. </param>
                    /// <returns>The extended and transformed <see cref="Vector3"/>.</returns>
                    public static Vector3 Transform(Vector2 position, Matrix matrix){ Vector3 result;
                        result = new Vector3(position.X * matrix.M11 + position.Y * matrix.M21 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + matrix.M43);
                    return result; }
                                    /// <summary>Transform a <see cref="Vector2"/> by a <see cref="Matrix"/>, extending the <see cref="Vector2"/> to produce a <see cref="Z"/> value of 0 and a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector2"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector3"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="result">The extended and transformed <see cref="Vector3"/>. The parameter may point to any member of the other parameters without affecting the result.</param>
                    public static void Transform(ref Vector2 position, ref Matrix matrix, out Vector3 result){
                        result = new Vector3(position.X * matrix.M11 + position.Y * matrix.M21 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + matrix.M43);
                    }
                            
                        
                                                            /// <summary>Transforms a <see cref="Vector3"/> by a <see cref="Quaternion"/> rotation.</summary>
                    /// <param name="vector">The <see cref="Vector3"/> to transform. </param>
                    /// <param name="rotation">The <see cref="Quaternion"/> to rotate the <see cref="Vector3"/> by. </param>
                    /// <returns>The result of the transformation.</returns>
                    public static Vector3 Transform(Vector3 vector, Quaternion rotation){ Vector3 result;
                        float vz = vector.Z;
                        float x = 2 * (rotation.Y * vz - rotation.Z * vector.Y);
                        float y = 2 * (rotation.Z * vector.X - rotation.X * vz);
                        float z = 2 * (rotation.X * vector.Y - rotation.Y * vector.X);

                        result.X = vector.X + x * rotation.W + (rotation.Y * z - rotation.Z * y);
                        result.Y = vector.Y + y * rotation.W + (rotation.Z * x - rotation.X * z);
                                                    result.Z = vector.Z + z * rotation.W + (rotation.X * y - rotation.Y * x);
                                            return result; }
                                    /// <summary>Transforms a <see cref="Vector3"/> by a <see cref="Quaternion"/> rotation.</summary>
                    /// <param name="vector">The <see cref="Vector3"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="rotation">The <see cref="Quaternion"/> to rotate the <see cref="Vector3"/> by. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="result">The result of the transformation. The parameter may point to any member of the other parameters without affecting the result.</param>
                    public static void Transform(ref Vector3 vector, ref Quaternion rotation, out Vector3 result){
                        float vz = vector.Z;
                        float x = 2 * (rotation.Y * vz - rotation.Z * vector.Y);
                        float y = 2 * (rotation.Z * vector.X - rotation.X * vz);
                        float z = 2 * (rotation.X * vector.Y - rotation.Y * vector.X);

                        result.X = vector.X + x * rotation.W + (rotation.Y * z - rotation.Z * y);
                        result.Y = vector.Y + y * rotation.W + (rotation.Z * x - rotation.X * z);
                                                    result.Z = vector.Z + z * rotation.W + (rotation.X * y - rotation.Y * x);
                                            }
                            
            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <see cref="Vector3"/> values. The arrays may be the same.</summary>
            /// <param name="sourceArray">The array of <see cref="Vector3"/> values to transform.</param>
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <see cref="Vector3"/> values by.</param>
            /// <param name="destinationArray">The array to store transformed <see cref="Vector3"/> values in.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="sourceArray"/>'s <see cref="Array.Length"/> is greater than <paramref name="destinationArray"/>'s <see cref="Array.Length"/></exception>
            public static void Transform(Vector3[] sourceArray, ref Matrix matrix, Vector3[] destinationArray)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                Transform(sourceArray, 0, ref matrix, destinationArray, 0, sourceArray.Length);
            }

            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <see cref="Vector3"/> values. The arrays may be the same and the regions may overlap.</summary>
            /// <param name="sourceArray">The array of <see cref="Vector3"/> values to transform.</param>
            /// <param name="sourceIndex">The index of the first element of <paramref name="sourceArray"/> to transform.</param> 
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <see cref="Vector3"/> values by.</param>
            /// <param name="destinationArray">The array to store transformed <see cref="Vector3"/> values in.</param>
            /// <param name="destinationIndex">The index of the first element of <paramref name="destinationArray"/> to write to.</param>
            /// <param name="length">The number of <see cref="Vector3"/> values to transform.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/>, <paramref name="sourceIndex"/>, or <paramref name="destinationIndex"/> are below zero; or else the range given by <c><paramref name="sourceIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="sourceArray"/>; or else the range given by <c><paramref name="destinationIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="destinationArray"/>.</exception>
            public static void Transform(
                Vector3[] sourceArray,
                int sourceIndex,
                ref Matrix matrix,
                Vector3[] destinationArray,
                int destinationIndex,
                int length)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                if (destinationArray == null)
                    throw new ArgumentNullException("destinationArray");
                if (length < 0)
                    throw new ArgumentOutOfRangeException("length");
                if (sourceIndex < 0 || sourceIndex + length > sourceArray.Length)
                    throw new ArgumentOutOfRangeException("sourceIndex");
                if (destinationIndex < 0 || destinationIndex + length > destinationArray.Length)
                    throw new ArgumentOutOfRangeException("destinationIndex");

                // See whether we might need to iterate backwards.
                if (object.ReferenceEquals(sourceArray, destinationArray) && sourceIndex < destinationIndex)
                {
                    // We might need to iterate backwards, or else we'll overwrite source vertices before they're transformed.
                    // This is a "might" because we don't check for overlap, we just play it safe.
                    for (int index = length - 1; index >= 0; index--)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
                else
                {
                    for (int index = 0; index < length; index++)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
            }

                            /// <summary>Apply a <see cref="Quaternion"/> transform to an array of <see cref="Vector3"/> values. The arrays may be the same.</summary>
                /// <param name="sourceArray">The array of <see cref="Vector3"/> values to transform.</param>
                /// <param name="rotation">The <see cref="Quaternion"/> to transform the <see cref="Vector3"/> values by.</param>
                /// <param name="destinationArray">The array to store transformed <see cref="Vector3"/> values in.</param>
                /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
                /// <exception cref="ArgumentOutOfRangeException"><paramref name="sourceArray"/>'s <see cref="Array.Length"/> is greater than <paramref name="destinationArray"/>'s <see cref="Array.Length"/></exception>
                public static void Transform(Vector3[] sourceArray, ref Quaternion rotation, Vector3[] destinationArray)
                {
                    if (sourceArray == null)
                        throw new ArgumentNullException("sourceArray");
                    Transform(sourceArray, 0, ref rotation, destinationArray, 0, sourceArray.Length);
                }

                /// <summary>Apply a <see cref="Quaternion"/> transform to an array of <see cref="Vector3"/> values. The arrays may be the same and the regions may overlap.</summary>
                /// <param name="sourceArray">The array of <see cref="Vector3"/> values to transform.</param>
                /// <param name="sourceIndex">The index of the first element of <paramref name="sourceArray"/> to transform.</param> 
                /// <param name="rotation">The <see cref="Quaternion"/> to transform the <see cref="Vector3"/> values by.</param>
                /// <param name="destinationArray">The array to store transformed <see cref="Vector3"/> values in.</param>
                /// <param name="destinationIndex">The index of the first element of <paramref name="destinationArray"/> to write to.</param>
                /// <param name="length">The number of <see cref="Vector3"/> values to transform.</param>
                /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
                /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/>, <paramref name="sourceIndex"/>, or <paramref name="destinationIndex"/> are below zero; or else the range given by <c><paramref name="sourceIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="sourceArray"/>; or else the range given by <c><paramref name="destinationIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="destinationArray"/>.</exception>
                public static void Transform(
                    Vector3[] sourceArray,
                    int sourceIndex,
                    ref Quaternion rotation,
                    Vector3[] destinationArray,
                    int destinationIndex,
                    int length)
                {
                    if (sourceArray == null)
                        throw new ArgumentNullException("sourceArray");
                    if (destinationArray == null)
                        throw new ArgumentNullException("destinationArray");
                    if (length < 0)
                        throw new ArgumentOutOfRangeException("length");
                    if (sourceIndex < 0 || sourceIndex + length > sourceArray.Length)
                        throw new ArgumentOutOfRangeException("sourceIndex");
                    if (destinationIndex < 0 || destinationIndex + length > destinationArray.Length)
                        throw new ArgumentOutOfRangeException("destinationIndex");

                    // See whether we might need to iterate backwards.
                    if (object.ReferenceEquals(sourceArray, destinationArray) && sourceIndex < destinationIndex)
                    {
                        // We might need to iterate backwards, or else we'll overwrite source vertices before they're transformed.
                        // This is a "might" because we don't check for overlap, we just play it safe.
                        for (int index = length - 1; index >= 0; index--)
                            Transform(ref sourceArray[sourceIndex + index], ref rotation, out destinationArray[destinationIndex + index]);
                    }
                    else
                    {
                        for (int index = 0; index < length; index++)
                            Transform(ref sourceArray[sourceIndex + index], ref rotation, out destinationArray[destinationIndex + index]);
                    }
                }
            
                                                            /// <summary>Transform the <see cref="Vector3"/> by a <see cref="Matrix"/>, ignoring the translation component of the <see cref="Matrix"/>. The input and the results are not normalized.</summary>
                    /// <param name="position">The <see cref="Vector3"/> to transform. </param>
                    /// <param name="matrix">The transformation <see cref="Matrix"/>. </param>
                    /// <returns>The transformed <see cref="Vector3"/> normal.</returns>
                    public static Vector3 TransformNormal(Vector3 position, Matrix matrix){ Vector3 result;
                        result = new Vector3(                            // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21 + 
                                                            position.Z * matrix.M31
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22 + 
                                                            position.Z * matrix.M32
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M13 + 
                                                            position.Y * matrix.M23 + 
                                                            position.Z * matrix.M33
                                                
                            
                        );
                    return result; }
                                    /// <summary>Transform the <see cref="Vector3"/> by a <see cref="Matrix"/>, ignoring the translation component of the <see cref="Matrix"/>. The input and the results are not normalized.</summary>
                    /// <param name="position">The <see cref="Vector3"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="matrix">The transformation <see cref="Matrix"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="result">The transformed <see cref="Vector3"/> normal. The parameter may point to any member of the other parameters without affecting the result.</param>
                    public static void TransformNormal(ref Vector3 position, ref Matrix matrix, out Vector3 result){
                        result = new Vector3(                            // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21 + 
                                                            position.Z * matrix.M31
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22 + 
                                                            position.Z * matrix.M32
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M13 + 
                                                            position.Y * matrix.M23 + 
                                                            position.Z * matrix.M33
                                                
                            
                        );
                    }
                            
            #endregion Public static methods

            #region Public methods

            /// <summary>Determine whether this <see cref="Vector3"/> and the other are equivalent, which is only possible if <paramref name="obj"/> is a <see cref="Vector3"/> with equivalent axes.</summary>
            /// <param name="obj">The object to compare to.</param>
            /// <returns>Whether the objects are equivalent.</returns>
            public override bool Equals(object obj)
            {
			    if(obj is Vector3)
			    {
                    Vector3 other = (Vector3)obj;
                    return X == other.X && Y == other.Y && Z == other.Z;
			    }
			
                return false;
            }

            /// <summary>Determine whether this <see cref="Vector3"/> and the other <see cref="Vector3"/> are equivalent in all components.</summary>
            /// <param name="other">The <see cref="Vector3"/> to compare to.</param>
            /// <returns>Whether the <see cref="Vector3"/> values are equivalent.</returns>
            public bool Equals(Vector3 other)
            {
                return X == other.X && Y == other.Y && Z == other.Z;
            }

            /// <summary>Get a hash code value that is as different from other, similiar <see cref="Vector3"/> as possible.</summary>
            /// <returns>The hash code value.</returns>
            public override int GetHashCode()
            {
                return X.GetHashCode() * 31 ^ Y.GetHashCode() * 31 ^ Z.GetHashCode() * 31;
            }

            /// <summary>Compute the length of the <see cref="Vector3"/>, which is the distance from the origin.</summary>
            /// <returns>The length of the <see cref="Vector3"/>.</returns>
            public float Length()
            {
                return (float)Math.Sqrt(X * X + Y * Y + Z * Z);
            }

            /// <summary>Compute the squared length of the <see cref="Vector3"/>, which is the squared distance from the origin. The squared length avoids a square root over <see cref="Length"/>, which is therefore faster.</summary>
            /// <returns>The squared length of the <see cref="Vector3"/>.</returns>
            public float LengthSquared()
            {
                return X * X + Y * Y + Z * Z;
            }

            /// <summary>Divide the <see cref="Vector3"/> by its <see cref="Length"/> so that its <see cref="Length"/> is one. If its original length is 0, then all components will be set to <c>float.NaN</c>.</summary>
            public void Normalize()
            {
                float inverseLength = 1.0f / (float)Math.Sqrt(X * X + Y * Y + Z * Z);
                X *= inverseLength;
Y *= inverseLength;
Z *= inverseLength;            }

            /// <summary>Convert to a string of the form "{X:x Y:y Z:z}".</summary>
            /// <returns>The string representation of this <see cref="Vector3"/>.</returns>
            public override string ToString()
            {
                CultureInfo currentCulture = CultureInfo.CurrentCulture;
                return string.Format(currentCulture, "{{X:{0} Y:{1} Z:{2}}}", new object[] { X.ToString(currentCulture), Y.ToString(currentCulture), Z.ToString(currentCulture) });
            }

            #endregion Public methods

            #region Operators and operator methods

            /// <summary>Compute the negative of the value (which is the value).</summary>
            /// <param name="value">The <see cref="Vector3"/>.</param>
            /// <returns>The <see cref="Vector3"/>.</returns>
            public static Vector3 operator +(Vector3 value)
            {
                value.X = +value.X;
value.Y = +value.Y;
value.Z = +value.Z;                return value;
            }

            /// <summary>Compute the negative of the value.</summary>
            /// <param name="value">The <see cref="Vector3"/> to negate.</param>
            /// <returns>The negated <see cref="Vector3"/>.</returns>
            public static Vector3 operator -(Vector3 value)
            {
                value.X = -value.X;
value.Y = -value.Y;
value.Z = -value.Z;                return value;
            }

            /// <summary>Compute whether the two <see cref="Vector3"/> values are equal.</summary>
            /// <param name="value1">The first <see cref="Vector3"/> to compare.</param>
            /// <param name="value2">The second <see cref="Vector3"/> to compare.</param>
            /// <returns>Whether the <see cref="Vector3"/> values are equal.</returns>
            public static bool operator ==(Vector3 value1, Vector3 value2)
            {
                return value1.X == value2.X&&value1.Y == value2.Y&&value1.Z == value2.Z;
            }

            /// <summary>Compute whether the two <see cref="Vector3"/> values are not equal.</summary>
            /// <param name="value1">The first <see cref="Vector3"/> to compare.</param>
            /// <param name="value2">The second <see cref="Vector3"/> to compare.</param>
            /// <returns>Whether the <see cref="Vector3"/> values are not equal.</returns>
            public static bool operator !=(Vector3 value1, Vector3 value2)
            {
                return value1.X != value2.X||value1.Y != value2.Y||value1.Z != value2.Z;
            }

                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Add the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Add(Vector3 value1, Vector3 value2){ Vector3 result;
                    result.X = value1.X + value2.X;
result.Y = value1.Y + value2.Y;
result.Z = value1.Z + value2.Z;                return result; }
                                /// <summary>Add the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(ref Vector3 value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1.X + value2.X;
result.Y = value1.Y + value2.Y;
result.Z = value1.Z + value2.Z;                }
                
                                /// <summary>AddThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Add(Vector3 value1, float value2){ Vector3 result;
                    result.X = value1.X + value2;
result.Y = value1.Y + value2;
result.Z = value1.Z + value2;                return result; }
                                /// <summary>AddThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(ref Vector3 value1, float value2, out Vector3 result){
                    result.X = value1.X + value2;
result.Y = value1.Y + value2;
result.Z = value1.Z + value2;                }
                
                                /// <summary>AddThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Add(float value1, Vector3 value2){ Vector3 result;
                    result.X = value1 + value2.X;
result.Y = value1 + value2.Y;
result.Z = value1 + value2.Z;                return result; }
                                /// <summary>AddThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(float value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1 + value2.X;
result.Y = value1 + value2.Y;
result.Z = value1 + value2.Z;                }
                
                /// <summary>Add the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator +(Vector3 value1, Vector3 value2)
                {
                    value1.X += value2.X;
value1.Y += value2.Y;
value1.Z += value2.Z;                    return value1;
                }

                /// <summary>Add the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator +(Vector3 value1, float value2)
                {
                    value1.X += value2;
value1.Y += value2;
value1.Z += value2;                    return value1;
                }

                /// <summary>Add the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator +(float value1, Vector3 value2)
                {
                    value2.X = value1 + value2.X;
value2.Y = value1 + value2.Y;
value2.Z = value1 + value2.Z;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Subtract the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Subtract(Vector3 value1, Vector3 value2){ Vector3 result;
                    result.X = value1.X - value2.X;
result.Y = value1.Y - value2.Y;
result.Z = value1.Z - value2.Z;                return result; }
                                /// <summary>Subtract the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(ref Vector3 value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1.X - value2.X;
result.Y = value1.Y - value2.Y;
result.Z = value1.Z - value2.Z;                }
                
                                /// <summary>SubtractThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Subtract(Vector3 value1, float value2){ Vector3 result;
                    result.X = value1.X - value2;
result.Y = value1.Y - value2;
result.Z = value1.Z - value2;                return result; }
                                /// <summary>SubtractThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(ref Vector3 value1, float value2, out Vector3 result){
                    result.X = value1.X - value2;
result.Y = value1.Y - value2;
result.Z = value1.Z - value2;                }
                
                                /// <summary>SubtractThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Subtract(float value1, Vector3 value2){ Vector3 result;
                    result.X = value1 - value2.X;
result.Y = value1 - value2.Y;
result.Z = value1 - value2.Z;                return result; }
                                /// <summary>SubtractThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(float value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1 - value2.X;
result.Y = value1 - value2.Y;
result.Z = value1 - value2.Z;                }
                
                /// <summary>Subtract the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator -(Vector3 value1, Vector3 value2)
                {
                    value1.X -= value2.X;
value1.Y -= value2.Y;
value1.Z -= value2.Z;                    return value1;
                }

                /// <summary>Subtract the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator -(Vector3 value1, float value2)
                {
                    value1.X -= value2;
value1.Y -= value2;
value1.Z -= value2;                    return value1;
                }

                /// <summary>Subtract the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator -(float value1, Vector3 value2)
                {
                    value2.X = value1 - value2.X;
value2.Y = value1 - value2.Y;
value2.Z = value1 - value2.Z;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Multiply the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Multiply(Vector3 value1, Vector3 value2){ Vector3 result;
                    result.X = value1.X * value2.X;
result.Y = value1.Y * value2.Y;
result.Z = value1.Z * value2.Z;                return result; }
                                /// <summary>Multiply the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(ref Vector3 value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1.X * value2.X;
result.Y = value1.Y * value2.Y;
result.Z = value1.Z * value2.Z;                }
                
                                /// <summary>MultiplyThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Multiply(Vector3 value1, float value2){ Vector3 result;
                    result.X = value1.X * value2;
result.Y = value1.Y * value2;
result.Z = value1.Z * value2;                return result; }
                                /// <summary>MultiplyThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(ref Vector3 value1, float value2, out Vector3 result){
                    result.X = value1.X * value2;
result.Y = value1.Y * value2;
result.Z = value1.Z * value2;                }
                
                                /// <summary>MultiplyThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Multiply(float value1, Vector3 value2){ Vector3 result;
                    result.X = value1 * value2.X;
result.Y = value1 * value2.Y;
result.Z = value1 * value2.Z;                return result; }
                                /// <summary>MultiplyThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(float value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1 * value2.X;
result.Y = value1 * value2.Y;
result.Z = value1 * value2.Z;                }
                
                /// <summary>Multiply the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator *(Vector3 value1, Vector3 value2)
                {
                    value1.X *= value2.X;
value1.Y *= value2.Y;
value1.Z *= value2.Z;                    return value1;
                }

                /// <summary>Multiply the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator *(Vector3 value1, float value2)
                {
                    value1.X *= value2;
value1.Y *= value2;
value1.Z *= value2;                    return value1;
                }

                /// <summary>Multiply the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator *(float value1, Vector3 value2)
                {
                    value2.X = value1 * value2.X;
value2.Y = value1 * value2.Y;
value2.Z = value1 * value2.Z;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Divide the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Divide(Vector3 value1, Vector3 value2){ Vector3 result;
                    result.X = value1.X / value2.X;
result.Y = value1.Y / value2.Y;
result.Z = value1.Z / value2.Z;                return result; }
                                /// <summary>Divide the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(ref Vector3 value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1.X / value2.X;
result.Y = value1.Y / value2.Y;
result.Z = value1.Z / value2.Z;                }
                
                                /// <summary>DivideThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Divide(Vector3 value1, float value2){ Vector3 result;
                    result.X = value1.X / value2;
result.Y = value1.Y / value2;
result.Z = value1.Z / value2;                return result; }
                                /// <summary>DivideThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(ref Vector3 value1, float value2, out Vector3 result){
                    result.X = value1.X / value2;
result.Y = value1.Y / value2;
result.Z = value1.Z / value2;                }
                
                                /// <summary>DivideThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Divide(float value1, Vector3 value2){ Vector3 result;
                    result.X = value1 / value2.X;
result.Y = value1 / value2.Y;
result.Z = value1 / value2.Z;                return result; }
                                /// <summary>DivideThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(float value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1 / value2.X;
result.Y = value1 / value2.Y;
result.Z = value1 / value2.Z;                }
                
                /// <summary>Divide the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator /(Vector3 value1, Vector3 value2)
                {
                    value1.X /= value2.X;
value1.Y /= value2.Y;
value1.Z /= value2.Z;                    return value1;
                }

                /// <summary>Divide the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator /(Vector3 value1, float value2)
                {
                    value1.X /= value2;
value1.Y /= value2;
value1.Z /= value2;                    return value1;
                }

                /// <summary>Divide the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator /(float value1, Vector3 value2)
                {
                    value2.X = value1 / value2.X;
value2.Y = value1 / value2.Y;
value2.Z = value1 / value2.Z;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Modulo the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Modulo(Vector3 value1, Vector3 value2){ Vector3 result;
                    result.X = value1.X % value2.X;
result.Y = value1.Y % value2.Y;
result.Z = value1.Z % value2.Z;                return result; }
                                /// <summary>Modulo the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(ref Vector3 value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1.X % value2.X;
result.Y = value1.Y % value2.Y;
result.Z = value1.Z % value2.Z;                }
                
                                /// <summary>ModuloThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Modulo(Vector3 value1, float value2){ Vector3 result;
                    result.X = value1.X % value2;
result.Y = value1.Y % value2;
result.Z = value1.Z % value2;                return result; }
                                /// <summary>ModuloThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector3"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(ref Vector3 value1, float value2, out Vector3 result){
                    result.X = value1.X % value2;
result.Y = value1.Y % value2;
result.Z = value1.Z % value2;                }
                
                                /// <summary>ModuloThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 Modulo(float value1, Vector3 value2){ Vector3 result;
                    result.X = value1 % value2.X;
result.Y = value1 % value2.Y;
result.Z = value1 % value2.Z;                return result; }
                                /// <summary>ModuloThe components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector3"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(float value1, ref Vector3 value2, out Vector3 result){
                    result.X = value1 % value2.X;
result.Y = value1 % value2.Y;
result.Z = value1 % value2.Z;                }
                
                /// <summary>Modulo the components of the <see cref="Vector3"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator %(Vector3 value1, Vector3 value2)
                {
                    value1.X %= value2.X;
value1.Y %= value2.Y;
value1.Z %= value2.Z;                    return value1;
                }

                /// <summary>Modulo the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator %(Vector3 value1, float value2)
                {
                    value1.X %= value2;
value1.Y %= value2;
value1.Z %= value2;                    return value1;
                }

                /// <summary>Modulo the components of a <see cref="Vector3"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector3 operator %(float value1, Vector3 value2)
                {
                    value2.X = value1 % value2.X;
value2.Y = value1 % value2.Y;
value2.Z = value1 % value2.Z;                    return value2;
                }
            
            #endregion Operators and operator methods
        }

                    
        
        /// <summary>A four-dimensional floating-point <a href="http://en.wikipedia.org/wiki/Column_vector">column vector</a>.</summary>
        [DataContract]
        partial struct Vector4 : IEquatable<Vector4>
        {
            #region Private fields

            // Implementation note: These constants cannot be "readonly" because they are passed by reference in the implementation.

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static Vector4 zero = new Vector4(0f, 0f, 0f, 0f);

            /// <summary>Backing field of the <see cref="Zero"/> property.</summary>
            private static Vector4 one = new Vector4(1f, 1f, 1f, 1f);

                            /// <summary>Backing field of the <see cref="UnitX"/> property.</summary>
                private static Vector4 unitX = new Vector4(1f, 0f, 0f, 0f);
                            /// <summary>Backing field of the <see cref="UnitY"/> property.</summary>
                private static Vector4 unitY = new Vector4(0f, 1f, 0f, 0f);
                            /// <summary>Backing field of the <see cref="UnitZ"/> property.</summary>
                private static Vector4 unitZ = new Vector4(0f, 0f, 1f, 0f);
                            /// <summary>Backing field of the <see cref="UnitW"/> property.</summary>
                private static Vector4 unitW = new Vector4(0f, 0f, 0f, 1f);
            
            #endregion Private fields

            #region Public fields

                            /// <summary>
                /// The first axis of the <see cref="Vector4"/>.
                /// </summary>
                [DataMember]
                public float X;
                            /// <summary>
                /// The second axis of the <see cref="Vector4"/>.
                /// </summary>
                [DataMember]
                public float Y;
                            /// <summary>
                /// The third axis of the <see cref="Vector4"/>.
                /// </summary>
                [DataMember]
                public float Z;
                            /// <summary>
                /// The fourth axis of the <see cref="Vector4"/>.
                /// </summary>
                [DataMember]
                public float W;
            
            #endregion Public fields

            #region Properties

            /// <summary>Get a <see cref="Vector4"/> where all of the components are zero.</summary>
            public static Vector4 Zero { get { return zero; } }

            /// <summary>Get a <see cref="Vector4"/> where all of the components are one.</summary>
            public static Vector4 One { get { return one; } }

                            /// <summary>Get a <see cref="Vector4"/> where the X component is one and the rest are zero.</summary>
                public static Vector4 UnitX { get { return unitX; } }
                            /// <summary>Get a <see cref="Vector4"/> where the Y component is one and the rest are zero.</summary>
                public static Vector4 UnitY { get { return unitY; } }
                            /// <summary>Get a <see cref="Vector4"/> where the Z component is one and the rest are zero.</summary>
                public static Vector4 UnitZ { get { return unitZ; } }
                            /// <summary>Get a <see cref="Vector4"/> where the W component is one and the rest are zero.</summary>
                public static Vector4 UnitW { get { return unitW; } }
            
            #endregion Properties

            #region Constructors

            /// <summary>Initialize the components of the <see cref="Vector4"/>.</summary>
            /// <param name="x">Value for the <see cref="X"/> component.</param>
/// <param name="y">Value for the <see cref="Y"/> component.</param>
/// <param name="z">Value for the <see cref="Z"/> component.</param>
/// <param name="w">Value for the <see cref="W"/> component.</param>
            public Vector4(float x, float y, float z, float w)
            {
                X = x;
Y = y;
Z = z;
W = w;            }

            /// <summary>Initialize the components of the Vector4 to the same value.</summary>
            /// <param name="value">The value to assign to the X, Y, Z and W components.</param>
            public Vector4(float value)
            {
                X = Y = Z = W = value;
            }

            #endregion Constructors

            #region Public static methods

                            /// <summary>For each component of the <see cref="Vector4"/>s, compute the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate">Cartesian coordinate</a> for a point that is defined by a given triangle and two normalized <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)">barycentric (areal) coordinates</a>.</summary>
                /// <remarks>The effect of barycentric coordinates is that <paramref name="amount1"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value2"/> and <paramref name="amount2"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value3"/>, with zero for either amount being <paramref name="amount1"/> and one being the opposite corner. These coordinates are not linear.</remarks>
                /// <seealso cref="MathHelper.Barycentric"/>
                /// <param name="value1">The first vertex of the triangle. </param>
                /// <param name="value2">The second vertex of the triangle. </param>
                /// <param name="value3">The third vertex of the triangle. </param>
                /// <param name="amount1">The second barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value2"/>.</param>
                /// <param name="amount2">The third barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value3"/>.</param>
                /// <returns>The point at the given barycentric coordinates.</returns>
                public static Vector4 Barycentric(Vector4 value1, Vector4 value2, Vector4 value3, float amount1, float amount2){ Vector4 result;
                    result.X = MathHelper.Barycentric(value1.X, value2.X, value3.X, amount1, amount2);
result.Y = MathHelper.Barycentric(value1.Y, value2.Y, value3.Y, amount1, amount2);
result.Z = MathHelper.Barycentric(value1.Z, value2.Z, value3.Z, amount1, amount2);
result.W = MathHelper.Barycentric(value1.W, value2.W, value3.W, amount1, amount2);                return result; }
                            /// <summary>For each component of the <see cref="Vector4"/>s, compute the <a href="http://en.wikipedia.org/wiki/Cartesian_coordinate">Cartesian coordinate</a> for a point that is defined by a given triangle and two normalized <a href="http://en.wikipedia.org/wiki/Barycentric_coordinates_(mathematics)">barycentric (areal) coordinates</a>.</summary>
                /// <remarks>The effect of barycentric coordinates is that <paramref name="amount1"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value2"/> and <paramref name="amount2"/> specifies the interpolation between <paramref name="value1"/> and <paramref name="value3"/>, with zero for either amount being <paramref name="amount1"/> and one being the opposite corner. These coordinates are not linear.</remarks>
                /// <seealso cref="MathHelper.Barycentric"/>
                /// <param name="value1">The first vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value3">The third vertex of the triangle. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount1">The second barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value2"/>.</param>
                /// <param name="amount2">The third barycentric coordinate (the first is implicit), interpolating between <paramref name="value1"/> and <paramref name="value3"/>.</param>
                /// <param name="result">The point at the given barycentric coordinates. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Barycentric(ref Vector4 value1, ref Vector4 value2, ref Vector4 value3, float amount1, float amount2, out Vector4 result){
                    result.X = MathHelper.Barycentric(value1.X, value2.X, value3.X, amount1, amount2);
result.Y = MathHelper.Barycentric(value1.Y, value2.Y, value3.Y, amount1, amount2);
result.Z = MathHelper.Barycentric(value1.Z, value2.Z, value3.Z, amount1, amount2);
result.W = MathHelper.Barycentric(value1.W, value2.W, value3.W, amount1, amount2);                }
            
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Catmull-Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which passes through <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/>, and <paramref name="value4"/> as <paramref name="amount"/> increases from 0 to 1.</summary>
                /// <seealso cref="MathHelper.CatmullRom"/>
                /// <param name="value1">The first <see cref="Vector4"/> along the spline. </param>
                /// <param name="value2">The second <see cref="Vector4"/> along the spline. </param>
                /// <param name="value3">The third <see cref="Vector4"/> along the spline. </param>
                /// <param name="value4">The fourth <see cref="Vector4"/> along the spline. </param>
                /// <param name="amount">The amount to interpolate along the spline, generally between 0 and 1.</param>
                /// <returns>The interpolated point.</returns>
                public static Vector4 CatmullRom(Vector4 value1, Vector4 value2, Vector4 value3, Vector4 value4, float amount){ Vector4 result;
                    result.X = MathHelper.CatmullRom(value1.X, value2.X, value3.X, value4.X, amount);
result.Y = MathHelper.CatmullRom(value1.Y, value2.Y, value3.Y, value4.Y, amount);
result.Z = MathHelper.CatmullRom(value1.Z, value2.Z, value3.Z, value4.Z, amount);
result.W = MathHelper.CatmullRom(value1.W, value2.W, value3.W, value4.W, amount);                return result; }
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Catmull-Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which passes through <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/>, and <paramref name="value4"/> as <paramref name="amount"/> increases from 0 to 1.</summary>
                /// <seealso cref="MathHelper.CatmullRom"/>
                /// <param name="value1">The first <see cref="Vector4"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector4"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value3">The third <see cref="Vector4"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value4">The fourth <see cref="Vector4"/> along the spline. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate along the spline, generally between 0 and 1.</param>
                /// <param name="result">The interpolated point. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void CatmullRom(ref Vector4 value1, ref Vector4 value2, ref Vector4 value3, ref Vector4 value4, float amount, out Vector4 result){
                    result.X = MathHelper.CatmullRom(value1.X, value2.X, value3.X, value4.X, amount);
result.Y = MathHelper.CatmullRom(value1.Y, value2.Y, value3.Y, value4.Y, amount);
result.Z = MathHelper.CatmullRom(value1.Z, value2.Z, value3.Z, value4.Z, amount);
result.W = MathHelper.CatmullRom(value1.W, value2.W, value3.W, value4.W, amount);                }
            
                            /// <summary>Restrict the components of the <see cref="Vector4"/> to upper and lower boundaries.</summary>
                /// <param name="value1">The value to clamp. </param>
                /// <param name="min">The lower boundary. </param>
                /// <param name="max">The upper boundary. </param>
                /// <returns>The clamped value.</returns>
                public static Vector4 Clamp(Vector4 value1, Vector4 min, Vector4 max){ Vector4 result;
                    result.X = MathHelper.Clamp(value1.X, min.X, max.X);
result.Y = MathHelper.Clamp(value1.Y, min.Y, max.Y);
result.Z = MathHelper.Clamp(value1.Z, min.Z, max.Z);
result.W = MathHelper.Clamp(value1.W, min.W, max.W);                return result; }
                            /// <summary>Restrict the components of the <see cref="Vector4"/> to upper and lower boundaries.</summary>
                /// <param name="value1">The value to clamp. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="min">The lower boundary. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="max">The upper boundary. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The clamped value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Clamp(ref Vector4 value1, ref Vector4 min, ref Vector4 max, out Vector4 result){
                    result.X = MathHelper.Clamp(value1.X, min.X, max.X);
result.Y = MathHelper.Clamp(value1.Y, min.Y, max.Y);
result.Z = MathHelper.Clamp(value1.Z, min.Z, max.Z);
result.W = MathHelper.Clamp(value1.W, min.W, max.W);                }
            
                            /// <summary>Compute the distance between the two <see cref="Vector4"/>.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. </param>
                /// <param name="value2">The second <see cref="Vector4"/>. </param>
                /// <returns>The distance between the two <see cref="Vector4"/> objects.</returns>
                public static float Distance(Vector4 value1, Vector4 value2){ float result;
                    float X = value2.X - value1.X, Y = value2.Y - value1.Y, Z = value2.Z - value1.Z, W = value2.W - value1.W;
                    result = (float)Math.Sqrt(X * X + Y * Y + Z * Z + W * W);
                return result; }
                            /// <summary>Compute the distance between the two <see cref="Vector4"/>.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The distance between the two <see cref="Vector4"/> objects. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Distance(ref Vector4 value1, ref Vector4 value2, out float result){
                    float X = value2.X - value1.X, Y = value2.Y - value1.Y, Z = value2.Z - value1.Z, W = value2.W - value1.W;
                    result = (float)Math.Sqrt(X * X + Y * Y + Z * Z + W * W);
                }
            
                            /// <summary>Compute the squared distance between the two <see cref="Vector4"/>, which saves a square root over <see cref="Distance(Vector4,Vector4)"/></summary>
                /// <param name="value1">The first <see cref="Vector4"/>. </param>
                /// <param name="value2">The second <see cref="Vector4"/>. </param>
                /// <returns>The squared distance between the two <see cref="Vector4"/> values.</returns>
                public static float DistanceSquared(Vector4 value1, Vector4 value2){ float result;
                    float x = value2.X - value1.X, y = value2.Y - value1.Y, z = value2.Z - value1.Z, w = value2.W - value1.W;
                    result = x * x + y * y + z * z + w * w;
                return result; }
                            /// <summary>Compute the squared distance between the two <see cref="Vector4"/>, which saves a square root over <see cref="Distance(Vector4,Vector4)"/></summary>
                /// <param name="value1">The first <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The squared distance between the two <see cref="Vector4"/> values. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void DistanceSquared(ref Vector4 value1, ref Vector4 value2, out float result){
                    float x = value2.X - value1.X, y = value2.Y - value1.Y, z = value2.Z - value1.Z, w = value2.W - value1.W;
                    result = x * x + y * y + z * z + w * w;
                }
            
                            /// <summary>Compute the <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> of the two <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. </param>
                /// <param name="value2">The second <see cref="Vector4"/>. </param>
                /// <returns>The dot product of the parameters.</returns>
                public static float Dot(Vector4 value1, Vector4 value2){ float result;
                    result = value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
                return result; }
                            /// <summary>Compute the <a href="http://en.wikipedia.org/wiki/Dot_product">dot product</a> of the two <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The dot product of the parameters. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Dot(ref Vector4 value1, ref Vector4 value2, out float result){
                    result = value1.X * value2.X + value1.Y * value2.Y + value1.Z * value2.Z + value1.W * value2.W;
                }
            
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>.</summary>
                /// <param name="value1">The starting point.</param>
                /// <param name="tangent1">The tangent (the direction) of the spline at the start. </param>
                /// <param name="value2">The ending point. </param>
                /// <param name="tangent2">The tangent (the direction) of the spline at the end. </param>
                /// <param name="amount">The amount to interpolate on the curve between <paramref name="value1"/> (at <c>0.0f</c>) and <paramref name="value2"/> (at <c>1.0f</c>).</param>
                /// <returns>The interpolated value.</returns>
                public static Vector4 Hermite(Vector4 value1, Vector4 tangent1, Vector4 value2, Vector4 tangent2, float amount){ Vector4 result;
                    result.X = MathHelper.Hermite(value1.X, tangent1.X, value2.X, tangent2.X, amount);
result.Y = MathHelper.Hermite(value1.Y, tangent1.Y, value2.Y, tangent2.Y, amount);
result.Z = MathHelper.Hermite(value1.Z, tangent1.Z, value2.Z, tangent2.Z, amount);
result.W = MathHelper.Hermite(value1.W, tangent1.W, value2.W, tangent2.W, amount);                return result; }
                            /// <summary>Interpolate along a <a href="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>.</summary>
                /// <param name="value1">The starting point.</param>
                /// <param name="tangent1">The tangent (the direction) of the spline at the start. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The ending point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="tangent2">The tangent (the direction) of the spline at the end. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate on the curve between <paramref name="value1"/> (at <c>0.0f</c>) and <paramref name="value2"/> (at <c>1.0f</c>).</param>
                /// <param name="result">The interpolated value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Hermite(ref Vector4 value1, ref Vector4 tangent1, ref Vector4 value2, ref Vector4 tangent2, float amount, out Vector4 result){
                    result.X = MathHelper.Hermite(value1.X, tangent1.X, value2.X, tangent2.X, amount);
result.Y = MathHelper.Hermite(value1.Y, tangent1.Y, value2.Y, tangent2.Y, amount);
result.Z = MathHelper.Hermite(value1.Z, tangent1.Z, value2.Z, tangent2.Z, amount);
result.W = MathHelper.Hermite(value1.W, tangent1.W, value2.W, tangent2.W, amount);                }
            
                            /// <summary>Linearly interpolate between the two <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The starting <see cref="Vector4"/> value. </param>
                /// <param name="value2">The ending <see cref="Vector4"/> value. </param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <returns>The interpolated <see cref="Vector4"/> value.</returns>
                public static Vector4 Lerp(Vector4 value1, Vector4 value2, float amount){ Vector4 result;
                    result.X = MathHelper.Lerp(value1.X, value2.X, amount);
result.Y = MathHelper.Lerp(value1.Y, value2.Y, amount);
result.Z = MathHelper.Lerp(value1.Z, value2.Z, amount);
result.W = MathHelper.Lerp(value1.W, value2.W, amount);                return result; }
                            /// <summary>Linearly interpolate between the two <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The starting <see cref="Vector4"/> value. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The ending <see cref="Vector4"/> value. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <param name="result">The interpolated <see cref="Vector4"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Lerp(ref Vector4 value1, ref Vector4 value2, float amount, out Vector4 result){
                    result.X = MathHelper.Lerp(value1.X, value2.X, amount);
result.Y = MathHelper.Lerp(value1.Y, value2.Y, amount);
result.Z = MathHelper.Lerp(value1.Z, value2.Z, amount);
result.W = MathHelper.Lerp(value1.W, value2.W, amount);                }
            
                            /// <summary>Compute the maximum of each component of the <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. </param>
                /// <param name="value2">The second <see cref="Vector4"/>. </param>
                /// <returns>A <see cref="Vector4"/> containing the maximum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector4"/>'s components.</returns>
                public static Vector4 Max(Vector4 value1, Vector4 value2){ Vector4 result;
                    result.X = Math.Max(value1.X, value2.X);
result.Y = Math.Max(value1.Y, value2.Y);
result.Z = Math.Max(value1.Z, value2.Z);
result.W = Math.Max(value1.W, value2.W);                return result; }
                            /// <summary>Compute the maximum of each component of the <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">A <see cref="Vector4"/> containing the maximum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector4"/>'s components. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Max(ref Vector4 value1, ref Vector4 value2, out Vector4 result){
                    result.X = Math.Max(value1.X, value2.X);
result.Y = Math.Max(value1.Y, value2.Y);
result.Z = Math.Max(value1.Z, value2.Z);
result.W = Math.Max(value1.W, value2.W);                }
            

                            /// <summary>Compute the minimum of each component of the <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. </param>
                /// <param name="value2">The second <see cref="Vector4"/>. </param>
                /// <returns>A <see cref="Vector4"/> containing the minimum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector4"/>'s components.</returns>
                public static Vector4 Min(Vector4 value1, Vector4 value2){ Vector4 result;
                    result.X = Math.Min(value1.X, value2.X);
result.Y = Math.Min(value1.Y, value2.Y);
result.Z = Math.Min(value1.Z, value2.Z);
result.W = Math.Min(value1.W, value2.W);                return result; }
                            /// <summary>Compute the minimum of each component of the <see cref="Vector4"/> values.</summary>
                /// <param name="value1">The first <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The second <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">A <see cref="Vector4"/> containing the minimum of the <paramref name="value1"/> and <paramref name="value2"/> <see cref="Vector4"/>'s components. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Min(ref Vector4 value1, ref Vector4 value2, out Vector4 result){
                    result.X = Math.Min(value1.X, value2.X);
result.Y = Math.Min(value1.Y, value2.Y);
result.Z = Math.Min(value1.Z, value2.Z);
result.W = Math.Min(value1.W, value2.W);                }
            
                            /// <summary>Compute the negative of each component of the <see cref="Vector4"/>.</summary>
                /// <param name="value">The <see cref="Vector4"/> to negate. </param>
                /// <returns>The negative <see cref="Vector4"/> value.</returns>
                public static Vector4 Negate(Vector4 value){ Vector4 result;
                    result.X = -value.X;
result.Y = -value.Y;
result.Z = -value.Z;
result.W = -value.W;                return result; }
                            /// <summary>Compute the negative of each component of the <see cref="Vector4"/>.</summary>
                /// <param name="value">The <see cref="Vector4"/> to negate. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The negative <see cref="Vector4"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Negate(ref Vector4 value, out Vector4 result){
                    result.X = -value.X;
result.Y = -value.Y;
result.Z = -value.Z;
result.W = -value.W;                }
            
                            /// <summary>Divide a <see cref="Vector4"/> by its <see cref="Length"/>, resulting in a <see cref="Vector4"/> with a <see cref="Length"/> of one. If the <see cref="Vector4"/>'s original <see cref="Length"/> is one, then the result's components will all be <c>float.NaN</c>.</summary>
                /// <param name="value">The <see cref="Vector4"/> to normalize. </param>
                /// <returns>The normalized (or invalid) <see cref="Vector4"/> value.</returns>
                public static Vector4 Normalize(Vector4 value){ Vector4 result;
                    float inverseLength = 1.0f / (float)Math.Sqrt(value.X * value.X + value.Y * value.Y + value.Z * value.Z + value.W * value.W);
                    result.X = value.X * inverseLength;
result.Y = value.Y * inverseLength;
result.Z = value.Z * inverseLength;
result.W = value.W * inverseLength;                return result; }
                            /// <summary>Divide a <see cref="Vector4"/> by its <see cref="Length"/>, resulting in a <see cref="Vector4"/> with a <see cref="Length"/> of one. If the <see cref="Vector4"/>'s original <see cref="Length"/> is one, then the result's components will all be <c>float.NaN</c>.</summary>
                /// <param name="value">The <see cref="Vector4"/> to normalize. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The normalized (or invalid) <see cref="Vector4"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Normalize(ref Vector4 value, out Vector4 result){
                    float inverseLength = 1.0f / (float)Math.Sqrt(value.X * value.X + value.Y * value.Y + value.Z * value.Z + value.W * value.W);
                    result.X = value.X * inverseLength;
result.Y = value.Y * inverseLength;
result.Z = value.Z * inverseLength;
result.W = value.W * inverseLength;                }
            
                                        /// <summary>Reflect a <see cref="Vector4"/> over a normal.</summary>
                /// <param name="vector">The <see cref="Vector4"/> to reflect. </param>
                /// <param name="normal">The normalized <see cref="Vector4"/> that is perpendicular to the surface to reflect off of.</param>
                /// <returns>The reflected <see cref="Vector4"/> value.</returns>
                public static Vector4 Reflect(Vector4 vector, Vector4 normal){ Vector4 result;
                    // I is the original ray
                    // N is the normal of the incident plane
                    // R = I - (2 * N * DotProduct[I, N])
                    float dotProduct = vector.X * normal.X + vector.Y * normal.Y + vector.Z * normal.Z + vector.W * normal.W;

                    result.X = vector.X - (2.0f * normal.X) * dotProduct;
result.Y = vector.Y - (2.0f * normal.Y) * dotProduct;
result.Z = vector.Z - (2.0f * normal.Z) * dotProduct;
result.W = vector.W - (2.0f * normal.W) * dotProduct;                return result; }
                            /// <summary>Reflect a <see cref="Vector4"/> over a normal.</summary>
                /// <param name="vector">The <see cref="Vector4"/> to reflect. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="normal">The normalized <see cref="Vector4"/> that is perpendicular to the surface to reflect off of.</param>
                /// <param name="result">The reflected <see cref="Vector4"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Reflect(ref Vector4 vector, ref Vector4 normal, out Vector4 result){
                    // I is the original ray
                    // N is the normal of the incident plane
                    // R = I - (2 * N * DotProduct[I, N])
                    float dotProduct = vector.X * normal.X + vector.Y * normal.Y + vector.Z * normal.Z + vector.W * normal.W;

                    result.X = vector.X - (2.0f * normal.X) * dotProduct;
result.Y = vector.Y - (2.0f * normal.Y) * dotProduct;
result.Z = vector.Z - (2.0f * normal.Z) * dotProduct;
result.W = vector.W - (2.0f * normal.W) * dotProduct;                }
            
                                        /// <summary>Interpolate using a <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> curve.</summary>
                /// <param name="value1">The start point. </param>
                /// <param name="value2">The end point. </param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <returns>The interpolated <see cref="Vector4"/> value.</returns>
                public static Vector4 SmoothStep(Vector4 value1, Vector4 value2, float amount){ Vector4 result;
                    result.X = MathHelper.SmoothStep(value1.X, value2.X, amount);
result.Y = MathHelper.SmoothStep(value1.Y, value2.Y, amount);
result.Z = MathHelper.SmoothStep(value1.Z, value2.Z, amount);
result.W = MathHelper.SmoothStep(value1.W, value2.W, amount);                return result; }
                            /// <summary>Interpolate using a <a href="http://en.wikipedia.org/wiki/Smoothstep">Smoothstep</a> curve.</summary>
                /// <param name="value1">The start point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The end point. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="amount">The amount to interpolate between <paramref name="value1"/> (at 0) and <paramref name="value2"/> (at 1).</param>
                /// <param name="result">The interpolated <see cref="Vector4"/> value. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void SmoothStep(ref Vector4 value1, ref Vector4 value2, float amount, out Vector4 result){
                    result.X = MathHelper.SmoothStep(value1.X, value2.X, amount);
result.Y = MathHelper.SmoothStep(value1.Y, value2.Y, amount);
result.Z = MathHelper.SmoothStep(value1.Z, value2.Z, amount);
result.W = MathHelper.SmoothStep(value1.W, value2.W, amount);                }
            
                                        /// <summary>Transform the <see cref="Vector4"/> by the <see cref="Matrix"/>.</summary>
                /// <param name="position">The <see cref="Vector4"/> to transform. </param>
                /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. </param>
                /// <returns>The transformed <see cref="Vector4"/>.</returns>
                public static Vector4 Transform(Vector4 position, Matrix matrix){ Vector4 result;
                    result = new Vector4(
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21 + 
                                                            position.Z * matrix.M31 + 
                                                            position.W * matrix.M41
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22 + 
                                                            position.Z * matrix.M32 + 
                                                            position.W * matrix.M42
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M13 + 
                                                            position.Y * matrix.M23 + 
                                                            position.Z * matrix.M33 + 
                                                            position.W * matrix.M43
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M14 + 
                                                            position.Y * matrix.M24 + 
                                                            position.Z * matrix.M34 + 
                                                            position.W * matrix.M44
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            
                        );
                return result; }
                            /// <summary>Transform the <see cref="Vector4"/> by the <see cref="Matrix"/>.</summary>
                /// <param name="position">The <see cref="Vector4"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The transformed <see cref="Vector4"/>. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Transform(ref Vector4 position, ref Matrix matrix, out Vector4 result){
                    result = new Vector4(
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M11 + 
                                                            position.Y * matrix.M21 + 
                                                            position.Z * matrix.M31 + 
                                                            position.W * matrix.M41
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M12 + 
                                                            position.Y * matrix.M22 + 
                                                            position.Z * matrix.M32 + 
                                                            position.W * matrix.M42
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M13 + 
                                                            position.Y * matrix.M23 + 
                                                            position.Z * matrix.M33 + 
                                                            position.W * matrix.M43
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            , 
                                                    // Produce the "position.A * matrix.M## + ..." part.
                                                            position.X * matrix.M14 + 
                                                            position.Y * matrix.M24 + 
                                                            position.Z * matrix.M34 + 
                                                            position.W * matrix.M44
                            
                            // One-extend the W axis of vector types below order 4.
                                                
                            
                        );
                }
            
                                                            /// <summary>Transform a <see cref="Vector2"/> by a <see cref="Matrix"/>, extending the <see cref="Vector2"/> to produce a <see cref="Z"/> value of 0 and a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector2"/> to transform. </param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. </param>
                    /// <returns>The extended and transformed <see cref="Vector4"/>.</returns>
                    public static Vector4 Transform(Vector2 position, Matrix matrix){ Vector4 result;
                        result = new Vector4(position.X * matrix.M11 + position.Y * matrix.M21 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + matrix.M43, position.X * matrix.M14 + position.Y * matrix.M24 + matrix.M44);
                    return result; }
                                    /// <summary>Transform a <see cref="Vector2"/> by a <see cref="Matrix"/>, extending the <see cref="Vector2"/> to produce a <see cref="Z"/> value of 0 and a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector2"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="result">The extended and transformed <see cref="Vector4"/>. The parameter may point to any member of the other parameters without affecting the result.</param>
                    public static void Transform(ref Vector2 position, ref Matrix matrix, out Vector4 result){
                        result = new Vector4(position.X * matrix.M11 + position.Y * matrix.M21 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + matrix.M43, position.X * matrix.M14 + position.Y * matrix.M24 + matrix.M44);
                    }
                            
                                                            /// <summary>Transform a <see cref="Vector3"/> by a <see cref="Matrix"/>, extending the <see cref="Vector3"/> to produce a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector3"/> to transform. </param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. </param>
                    /// <returns>The extended and transformed <see cref="Vector4"/>.</returns>
                    public static Vector4 Transform(Vector3 position, Matrix matrix){ Vector4 result;
                        result = new Vector4(position.X * matrix.M11 + position.Y * matrix.M21 + position.Z * matrix.M31 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + position.Z * matrix.M32 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + position.Z * matrix.M33 + matrix.M43, position.X * matrix.M14 + position.Y * matrix.M24 + position.Z * matrix.M34 + matrix.M44);
                    return result; }
                                    /// <summary>Transform a <see cref="Vector3"/> by a <see cref="Matrix"/>, extending the <see cref="Vector3"/> to produce a <see cref="W"/> value of 1 (retaining the translation).</summary>
                    /// <param name="position">The <see cref="Vector3"/> to transform. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="matrix">The <see cref="Matrix"/> to use to transform the <see cref="Vector4"/>. The contents will not be modified; pass by reference is only for optimization.</param>
                    /// <param name="result">The extended and transformed <see cref="Vector4"/>. The parameter may point to any member of the other parameters without affecting the result.</param>
                    public static void Transform(ref Vector3 position, ref Matrix matrix, out Vector4 result){
                        result = new Vector4(position.X * matrix.M11 + position.Y * matrix.M21 + position.Z * matrix.M31 + matrix.M41, position.X * matrix.M12 + position.Y * matrix.M22 + position.Z * matrix.M32 + matrix.M42, position.X * matrix.M13 + position.Y * matrix.M23 + position.Z * matrix.M33 + matrix.M43, position.X * matrix.M14 + position.Y * matrix.M24 + position.Z * matrix.M34 + matrix.M44);
                    }
                            
                        
            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <see cref="Vector4"/> values. The arrays may be the same.</summary>
            /// <param name="sourceArray">The array of <see cref="Vector4"/> values to transform.</param>
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <see cref="Vector4"/> values by.</param>
            /// <param name="destinationArray">The array to store transformed <see cref="Vector4"/> values in.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="sourceArray"/>'s <see cref="Array.Length"/> is greater than <paramref name="destinationArray"/>'s <see cref="Array.Length"/></exception>
            public static void Transform(Vector4[] sourceArray, ref Matrix matrix, Vector4[] destinationArray)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                Transform(sourceArray, 0, ref matrix, destinationArray, 0, sourceArray.Length);
            }

            /// <summary>Apply a <see cref="Matrix"/> transform to an array of <see cref="Vector4"/> values. The arrays may be the same and the regions may overlap.</summary>
            /// <param name="sourceArray">The array of <see cref="Vector4"/> values to transform.</param>
            /// <param name="sourceIndex">The index of the first element of <paramref name="sourceArray"/> to transform.</param> 
            /// <param name="matrix">The <see cref="Matrix"/> to transform the <see cref="Vector4"/> values by.</param>
            /// <param name="destinationArray">The array to store transformed <see cref="Vector4"/> values in.</param>
            /// <param name="destinationIndex">The index of the first element of <paramref name="destinationArray"/> to write to.</param>
            /// <param name="length">The number of <see cref="Vector4"/> values to transform.</param>
            /// <exception cref="ArgumentNullException"><paramref name="sourceArray"/> or <paramref name="destinationArray"/> are <c>null</c>.</exception>
            /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/>, <paramref name="sourceIndex"/>, or <paramref name="destinationIndex"/> are below zero; or else the range given by <c><paramref name="sourceIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="sourceArray"/>; or else the range given by <c><paramref name="destinationIndex"/> + <paramref name="length"/></c> exceeds the bounds of <paramref name="destinationArray"/>.</exception>
            public static void Transform(
                Vector4[] sourceArray,
                int sourceIndex,
                ref Matrix matrix,
                Vector4[] destinationArray,
                int destinationIndex,
                int length)
            {
                if (sourceArray == null)
                    throw new ArgumentNullException("sourceArray");
                if (destinationArray == null)
                    throw new ArgumentNullException("destinationArray");
                if (length < 0)
                    throw new ArgumentOutOfRangeException("length");
                if (sourceIndex < 0 || sourceIndex + length > sourceArray.Length)
                    throw new ArgumentOutOfRangeException("sourceIndex");
                if (destinationIndex < 0 || destinationIndex + length > destinationArray.Length)
                    throw new ArgumentOutOfRangeException("destinationIndex");

                // See whether we might need to iterate backwards.
                if (object.ReferenceEquals(sourceArray, destinationArray) && sourceIndex < destinationIndex)
                {
                    // We might need to iterate backwards, or else we'll overwrite source vertices before they're transformed.
                    // This is a "might" because we don't check for overlap, we just play it safe.
                    for (int index = length - 1; index >= 0; index--)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
                else
                {
                    for (int index = 0; index < length; index++)
                        Transform(ref sourceArray[sourceIndex + index], ref matrix, out destinationArray[destinationIndex + index]);
                }
            }

            
                        
            #endregion Public static methods

            #region Public methods

            /// <summary>Determine whether this <see cref="Vector4"/> and the other are equivalent, which is only possible if <paramref name="obj"/> is a <see cref="Vector4"/> with equivalent axes.</summary>
            /// <param name="obj">The object to compare to.</param>
            /// <returns>Whether the objects are equivalent.</returns>
            public override bool Equals(object obj)
            {
			    if(obj is Vector4)
			    {
                    Vector4 other = (Vector4)obj;
                    return X == other.X && Y == other.Y && Z == other.Z && W == other.W;
			    }
			
                return false;
            }

            /// <summary>Determine whether this <see cref="Vector4"/> and the other <see cref="Vector4"/> are equivalent in all components.</summary>
            /// <param name="other">The <see cref="Vector4"/> to compare to.</param>
            /// <returns>Whether the <see cref="Vector4"/> values are equivalent.</returns>
            public bool Equals(Vector4 other)
            {
                return X == other.X && Y == other.Y && Z == other.Z && W == other.W;
            }

            /// <summary>Get a hash code value that is as different from other, similiar <see cref="Vector4"/> as possible.</summary>
            /// <returns>The hash code value.</returns>
            public override int GetHashCode()
            {
                return X.GetHashCode() * 31 ^ Y.GetHashCode() * 31 ^ Z.GetHashCode() * 31 ^ W.GetHashCode() * 31;
            }

            /// <summary>Compute the length of the <see cref="Vector4"/>, which is the distance from the origin.</summary>
            /// <returns>The length of the <see cref="Vector4"/>.</returns>
            public float Length()
            {
                return (float)Math.Sqrt(X * X + Y * Y + Z * Z + W * W);
            }

            /// <summary>Compute the squared length of the <see cref="Vector4"/>, which is the squared distance from the origin. The squared length avoids a square root over <see cref="Length"/>, which is therefore faster.</summary>
            /// <returns>The squared length of the <see cref="Vector4"/>.</returns>
            public float LengthSquared()
            {
                return X * X + Y * Y + Z * Z + W * W;
            }

            /// <summary>Divide the <see cref="Vector4"/> by its <see cref="Length"/> so that its <see cref="Length"/> is one. If its original length is 0, then all components will be set to <c>float.NaN</c>.</summary>
            public void Normalize()
            {
                float inverseLength = 1.0f / (float)Math.Sqrt(X * X + Y * Y + Z * Z + W * W);
                X *= inverseLength;
Y *= inverseLength;
Z *= inverseLength;
W *= inverseLength;            }

            /// <summary>Convert to a string of the form "{X:x Y:y Z:z W:w}".</summary>
            /// <returns>The string representation of this <see cref="Vector4"/>.</returns>
            public override string ToString()
            {
                CultureInfo currentCulture = CultureInfo.CurrentCulture;
                return string.Format(currentCulture, "{{X:{0} Y:{1} Z:{2} W:{3}}}", new object[] { X.ToString(currentCulture), Y.ToString(currentCulture), Z.ToString(currentCulture), W.ToString(currentCulture) });
            }

            #endregion Public methods

            #region Operators and operator methods

            /// <summary>Compute the negative of the value (which is the value).</summary>
            /// <param name="value">The <see cref="Vector4"/>.</param>
            /// <returns>The <see cref="Vector4"/>.</returns>
            public static Vector4 operator +(Vector4 value)
            {
                value.X = +value.X;
value.Y = +value.Y;
value.Z = +value.Z;
value.W = +value.W;                return value;
            }

            /// <summary>Compute the negative of the value.</summary>
            /// <param name="value">The <see cref="Vector4"/> to negate.</param>
            /// <returns>The negated <see cref="Vector4"/>.</returns>
            public static Vector4 operator -(Vector4 value)
            {
                value.X = -value.X;
value.Y = -value.Y;
value.Z = -value.Z;
value.W = -value.W;                return value;
            }

            /// <summary>Compute whether the two <see cref="Vector4"/> values are equal.</summary>
            /// <param name="value1">The first <see cref="Vector4"/> to compare.</param>
            /// <param name="value2">The second <see cref="Vector4"/> to compare.</param>
            /// <returns>Whether the <see cref="Vector4"/> values are equal.</returns>
            public static bool operator ==(Vector4 value1, Vector4 value2)
            {
                return value1.X == value2.X&&value1.Y == value2.Y&&value1.Z == value2.Z&&value1.W == value2.W;
            }

            /// <summary>Compute whether the two <see cref="Vector4"/> values are not equal.</summary>
            /// <param name="value1">The first <see cref="Vector4"/> to compare.</param>
            /// <param name="value2">The second <see cref="Vector4"/> to compare.</param>
            /// <returns>Whether the <see cref="Vector4"/> values are not equal.</returns>
            public static bool operator !=(Vector4 value1, Vector4 value2)
            {
                return value1.X != value2.X||value1.Y != value2.Y||value1.Z != value2.Z||value1.W != value2.W;
            }

                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Add the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Add(Vector4 value1, Vector4 value2){ Vector4 result;
                    result.X = value1.X + value2.X;
result.Y = value1.Y + value2.Y;
result.Z = value1.Z + value2.Z;
result.W = value1.W + value2.W;                return result; }
                                /// <summary>Add the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(ref Vector4 value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1.X + value2.X;
result.Y = value1.Y + value2.Y;
result.Z = value1.Z + value2.Z;
result.W = value1.W + value2.W;                }
                
                                /// <summary>AddThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Add(Vector4 value1, float value2){ Vector4 result;
                    result.X = value1.X + value2;
result.Y = value1.Y + value2;
result.Z = value1.Z + value2;
result.W = value1.W + value2;                return result; }
                                /// <summary>AddThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(ref Vector4 value1, float value2, out Vector4 result){
                    result.X = value1.X + value2;
result.Y = value1.Y + value2;
result.Z = value1.Z + value2;
result.W = value1.W + value2;                }
                
                                /// <summary>AddThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Add(float value1, Vector4 value2){ Vector4 result;
                    result.X = value1 + value2.X;
result.Y = value1 + value2.Y;
result.Z = value1 + value2.Z;
result.W = value1 + value2.W;                return result; }
                                /// <summary>AddThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Add(float value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1 + value2.X;
result.Y = value1 + value2.Y;
result.Z = value1 + value2.Z;
result.W = value1 + value2.W;                }
                
                /// <summary>Add the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator +(Vector4 value1, Vector4 value2)
                {
                    value1.X += value2.X;
value1.Y += value2.Y;
value1.Z += value2.Z;
value1.W += value2.W;                    return value1;
                }

                /// <summary>Add the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator +(Vector4 value1, float value2)
                {
                    value1.X += value2;
value1.Y += value2;
value1.Z += value2;
value1.W += value2;                    return value1;
                }

                /// <summary>Add the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator +(float value1, Vector4 value2)
                {
                    value2.X = value1 + value2.X;
value2.Y = value1 + value2.Y;
value2.Z = value1 + value2.Z;
value2.W = value1 + value2.W;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Subtract the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Subtract(Vector4 value1, Vector4 value2){ Vector4 result;
                    result.X = value1.X - value2.X;
result.Y = value1.Y - value2.Y;
result.Z = value1.Z - value2.Z;
result.W = value1.W - value2.W;                return result; }
                                /// <summary>Subtract the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(ref Vector4 value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1.X - value2.X;
result.Y = value1.Y - value2.Y;
result.Z = value1.Z - value2.Z;
result.W = value1.W - value2.W;                }
                
                                /// <summary>SubtractThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Subtract(Vector4 value1, float value2){ Vector4 result;
                    result.X = value1.X - value2;
result.Y = value1.Y - value2;
result.Z = value1.Z - value2;
result.W = value1.W - value2;                return result; }
                                /// <summary>SubtractThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(ref Vector4 value1, float value2, out Vector4 result){
                    result.X = value1.X - value2;
result.Y = value1.Y - value2;
result.Z = value1.Z - value2;
result.W = value1.W - value2;                }
                
                                /// <summary>SubtractThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Subtract(float value1, Vector4 value2){ Vector4 result;
                    result.X = value1 - value2.X;
result.Y = value1 - value2.Y;
result.Z = value1 - value2.Z;
result.W = value1 - value2.W;                return result; }
                                /// <summary>SubtractThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Subtract(float value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1 - value2.X;
result.Y = value1 - value2.Y;
result.Z = value1 - value2.Z;
result.W = value1 - value2.W;                }
                
                /// <summary>Subtract the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator -(Vector4 value1, Vector4 value2)
                {
                    value1.X -= value2.X;
value1.Y -= value2.Y;
value1.Z -= value2.Z;
value1.W -= value2.W;                    return value1;
                }

                /// <summary>Subtract the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator -(Vector4 value1, float value2)
                {
                    value1.X -= value2;
value1.Y -= value2;
value1.Z -= value2;
value1.W -= value2;                    return value1;
                }

                /// <summary>Subtract the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator -(float value1, Vector4 value2)
                {
                    value2.X = value1 - value2.X;
value2.Y = value1 - value2.Y;
value2.Z = value1 - value2.Z;
value2.W = value1 - value2.W;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Multiply the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Multiply(Vector4 value1, Vector4 value2){ Vector4 result;
                    result.X = value1.X * value2.X;
result.Y = value1.Y * value2.Y;
result.Z = value1.Z * value2.Z;
result.W = value1.W * value2.W;                return result; }
                                /// <summary>Multiply the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(ref Vector4 value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1.X * value2.X;
result.Y = value1.Y * value2.Y;
result.Z = value1.Z * value2.Z;
result.W = value1.W * value2.W;                }
                
                                /// <summary>MultiplyThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Multiply(Vector4 value1, float value2){ Vector4 result;
                    result.X = value1.X * value2;
result.Y = value1.Y * value2;
result.Z = value1.Z * value2;
result.W = value1.W * value2;                return result; }
                                /// <summary>MultiplyThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(ref Vector4 value1, float value2, out Vector4 result){
                    result.X = value1.X * value2;
result.Y = value1.Y * value2;
result.Z = value1.Z * value2;
result.W = value1.W * value2;                }
                
                                /// <summary>MultiplyThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Multiply(float value1, Vector4 value2){ Vector4 result;
                    result.X = value1 * value2.X;
result.Y = value1 * value2.Y;
result.Z = value1 * value2.Z;
result.W = value1 * value2.W;                return result; }
                                /// <summary>MultiplyThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Multiply(float value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1 * value2.X;
result.Y = value1 * value2.Y;
result.Z = value1 * value2.Z;
result.W = value1 * value2.W;                }
                
                /// <summary>Multiply the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator *(Vector4 value1, Vector4 value2)
                {
                    value1.X *= value2.X;
value1.Y *= value2.Y;
value1.Z *= value2.Z;
value1.W *= value2.W;                    return value1;
                }

                /// <summary>Multiply the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator *(Vector4 value1, float value2)
                {
                    value1.X *= value2;
value1.Y *= value2;
value1.Z *= value2;
value1.W *= value2;                    return value1;
                }

                /// <summary>Multiply the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator *(float value1, Vector4 value2)
                {
                    value2.X = value1 * value2.X;
value2.Y = value1 * value2.Y;
value2.Z = value1 * value2.Z;
value2.W = value1 * value2.W;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Divide the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Divide(Vector4 value1, Vector4 value2){ Vector4 result;
                    result.X = value1.X / value2.X;
result.Y = value1.Y / value2.Y;
result.Z = value1.Z / value2.Z;
result.W = value1.W / value2.W;                return result; }
                                /// <summary>Divide the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(ref Vector4 value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1.X / value2.X;
result.Y = value1.Y / value2.Y;
result.Z = value1.Z / value2.Z;
result.W = value1.W / value2.W;                }
                
                                /// <summary>DivideThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Divide(Vector4 value1, float value2){ Vector4 result;
                    result.X = value1.X / value2;
result.Y = value1.Y / value2;
result.Z = value1.Z / value2;
result.W = value1.W / value2;                return result; }
                                /// <summary>DivideThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(ref Vector4 value1, float value2, out Vector4 result){
                    result.X = value1.X / value2;
result.Y = value1.Y / value2;
result.Z = value1.Z / value2;
result.W = value1.W / value2;                }
                
                                /// <summary>DivideThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Divide(float value1, Vector4 value2){ Vector4 result;
                    result.X = value1 / value2.X;
result.Y = value1 / value2.Y;
result.Z = value1 / value2.Z;
result.W = value1 / value2.W;                return result; }
                                /// <summary>DivideThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Divide(float value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1 / value2.X;
result.Y = value1 / value2.Y;
result.Z = value1 / value2.Z;
result.W = value1 / value2.W;                }
                
                /// <summary>Divide the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator /(Vector4 value1, Vector4 value2)
                {
                    value1.X /= value2.X;
value1.Y /= value2.Y;
value1.Z /= value2.Z;
value1.W /= value2.W;                    return value1;
                }

                /// <summary>Divide the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator /(Vector4 value1, float value2)
                {
                    value1.X /= value2;
value1.Y /= value2;
value1.Z /= value2;
value1.W /= value2;                    return value1;
                }

                /// <summary>Divide the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator /(float value1, Vector4 value2)
                {
                    value2.X = value1 / value2.X;
value2.Y = value1 / value2.Y;
value2.Z = value1 / value2.Z;
value2.W = value1 / value2.W;                    return value2;
                }
                            // Vn Operator(Vn value1, Vn value2)
                                /// <summary>Modulo the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. </param>
                /// <param name="value2">The right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Modulo(Vector4 value1, Vector4 value2){ Vector4 result;
                    result.X = value1.X % value2.X;
result.Y = value1.Y % value2.Y;
result.Z = value1.Z % value2.Z;
result.W = value1.W % value2.W;                return result; }
                                /// <summary>Modulo the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(ref Vector4 value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1.X % value2.X;
result.Y = value1.Y % value2.Y;
result.Z = value1.Z % value2.Z;
result.W = value1.W % value2.W;                }
                
                                /// <summary>ModuloThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. </param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Modulo(Vector4 value1, float value2){ Vector4 result;
                    result.X = value1.X % value2;
result.Y = value1.Y % value2;
result.Z = value1.Z % value2;
result.W = value1.W % value2;                return result; }
                                /// <summary>ModuloThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The <see cref="Vector4"/> left side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="value2">The scalar right side of the equation.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(ref Vector4 value1, float value2, out Vector4 result){
                    result.X = value1.X % value2;
result.Y = value1.Y % value2;
result.Z = value1.Z % value2;
result.W = value1.W % value2;                }
                
                                /// <summary>ModuloThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. </param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 Modulo(float value1, Vector4 value2){ Vector4 result;
                    result.X = value1 % value2.X;
result.Y = value1 % value2.Y;
result.Z = value1 % value2.Z;
result.W = value1 % value2.W;                return result; }
                                /// <summary>ModuloThe components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The scalar left side of the equation.</param>
                /// <param name="value2">The <see cref="Vector4"/> right side of the equation. The contents will not be modified; pass by reference is only for optimization.</param>
                /// <param name="result">The result of the operation. The parameter may point to any member of the other parameters without affecting the result.</param>
                public static void Modulo(float value1, ref Vector4 value2, out Vector4 result){
                    result.X = value1 % value2.X;
result.Y = value1 % value2.Y;
result.Z = value1 % value2.Z;
result.W = value1 % value2.W;                }
                
                /// <summary>Modulo the components of the <see cref="Vector4"/>s.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator %(Vector4 value1, Vector4 value2)
                {
                    value1.X %= value2.X;
value1.Y %= value2.Y;
value1.Z %= value2.Z;
value1.W %= value2.W;                    return value1;
                }

                /// <summary>Modulo the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator %(Vector4 value1, float value2)
                {
                    value1.X %= value2;
value1.Y %= value2;
value1.Z %= value2;
value1.W %= value2;                    return value1;
                }

                /// <summary>Modulo the components of a <see cref="Vector4"/> with a scalar.</summary>
                /// <param name="value1">The left side of the equation.</param>
                /// <param name="value2">The right side of the equation.</param>
                /// <returns>The result of the operation.</returns>
                public static Vector4 operator %(float value1, Vector4 value2)
                {
                    value2.X = value1 % value2.X;
value2.Y = value1 % value2.Y;
value2.Z = value1 % value2.Z;
value2.W = value1 % value2.W;                    return value2;
                }
            
            #endregion Operators and operator methods
        }

            }



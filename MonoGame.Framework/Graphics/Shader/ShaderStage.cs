namespace Microsoft.Xna.Framework.Graphics
{
    internal enum ShaderStage
    {
        Vertex,
        Pixel,

        /// <summary>
        /// A hull shader is used in combination with a domain shader to turn low detail meshes into high detail meshes.
        /// The hull shader receives the output from the vertex shader and treats the vertices as control points of a subdivision surface.
        /// The control points form triangle or quad patches which are processed by the hull shader, and then fed into tesselation hardware present in modern GPU's.
        /// The tesselation hardware will subdivide the patches to generate high detail geometry.
        /// This high detail geometry is then fed into the domain shader for further processing. 
        /// </summary>
        Hull,

        /// <summary>
        /// A domain shader is used in combination with a hull shader to turn low detail meshes into high detail meshes.
        /// The domain shader runs after the hull shader. It's input is the high detail geometry generated by tesselation hardware present in modern GPU's.
        /// The hull shader's purpose is to generate the input for the pixel shader (or geometry shader if present).
        /// It usually performs similar tasks a vertex shader would perform when no tesselation is used (transforming vertices, displacement mapping, ...)
        /// </summary>
        Domain,

        /// <summary>
        /// Geometry shaders are used to generate extra geometry not present in the original mesh.
        /// The geometry shader runs after the vertex shader (or domain shader when tesselation is used) and before the pixel shader.
        /// For every input primitive a geometry shader usually generates multiple output primitives, but it's also posiible to dicard geometry by generating no output primitives. 
        /// </summary>
        Geometry,

        /// <summary>
        /// Compute shaders perform general purpose calculations on the GPU.
        /// </summary>
        Compute,
    }
}
